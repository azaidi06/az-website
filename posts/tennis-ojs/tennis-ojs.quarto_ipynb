{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Tennis Serve Analysis (Interactive)\"\n",
        "description: \"Explore serve statistics for top ATP and WTA players with interactive filters and visualizations\"\n",
        "author: \"Ahmad Zaidi\"\n",
        "date: \"2026-02-02\"\n",
        "categories: [tennis, sports analytics, visualization]\n",
        "image: \"preview.png\"\n",
        "format:\n",
        "  html:\n",
        "    page-layout: full\n",
        "    toc: true\n",
        "    toc-location: left\n",
        "execute:\n",
        "  echo: false\n",
        "  warning: false\n",
        "---"
      ],
      "id": "737c358c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: setup\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "from datetime import datetime, timedelta\n",
        "import json\n",
        "\n",
        "# Load data\n",
        "DATA_PATH = '../../data/top25'\n",
        "\n",
        "# Load ATP data\n",
        "atp_players = pd.read_csv(f'{DATA_PATH}/atp/atp_top25_players.csv')\n",
        "atp_matches = pd.read_csv(f'{DATA_PATH}/atp/atp_top25_matches.csv')\n",
        "atp_rankings = pd.read_csv(f'{DATA_PATH}/atp/atp_top25_rankings.csv')\n",
        "\n",
        "# Load WTA data\n",
        "wta_players = pd.read_csv(f'{DATA_PATH}/wta/wta_top25_players.csv')\n",
        "wta_matches = pd.read_csv(f'{DATA_PATH}/wta/wta_top25_matches.csv')\n",
        "wta_rankings = pd.read_csv(f'{DATA_PATH}/wta/wta_top25_rankings.csv')\n",
        "\n",
        "# Process player names\n",
        "for df in [atp_players, wta_players]:\n",
        "    df['full_name'] = df['name_first'] + ' ' + df['name_last']\n",
        "\n",
        "# Get most recent rankings\n",
        "latest_atp_date = atp_rankings['ranking_date'].max()\n",
        "latest_wta_date = wta_rankings['ranking_date'].max()\n",
        "latest_atp = atp_rankings[atp_rankings['ranking_date'] == latest_atp_date][['player', 'rank']]\n",
        "latest_wta = wta_rankings[wta_rankings['ranking_date'] == latest_wta_date][['player', 'rank']]\n",
        "\n",
        "# Merge rankings\n",
        "atp_players = atp_players.merge(latest_atp, left_on='player_id', right_on='player', how='left')\n",
        "wta_players = wta_players.merge(latest_wta, left_on='player_id', right_on='player', how='left')\n",
        "atp_players.drop(columns=['player'], inplace=True)\n",
        "wta_players.drop(columns=['player'], inplace=True)\n",
        "\n",
        "# Add tour indicator\n",
        "atp_players['tour'], wta_players['tour'] = 'ATP', 'WTA'\n",
        "atp_matches['tour'], wta_matches['tour'] = 'ATP', 'WTA'\n",
        "\n",
        "# Parse dates\n",
        "atp_matches['tourney_date'] = pd.to_datetime(atp_matches['tourney_date'].astype(str), format='%Y%m%d')\n",
        "wta_matches['tourney_date'] = pd.to_datetime(wta_matches['tourney_date'].astype(str), format='%Y%m%d')\n",
        "\n",
        "# Filter to matches with serve data\n",
        "serve_cols = ['w_ace', 'w_df', 'w_svpt', 'w_1stIn', 'w_1stWon', 'w_2ndWon', 'w_SvGms', 'w_bpSaved', 'w_bpFaced']\n",
        "atp_serve = atp_matches.dropna(subset=serve_cols).copy()\n",
        "wta_serve = wta_matches.dropna(subset=serve_cols).copy()"
      ],
      "id": "setup",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: compute-stats\n",
        "\n",
        "def filter_by_date_range(matches_df, start_date=None, end_date=None):\n",
        "    \"\"\"Filter matches by date range.\"\"\"\n",
        "    df = matches_df.copy()\n",
        "    if start_date is not None:\n",
        "        df = df[df['tourney_date'] >= pd.Timestamp(start_date)]\n",
        "    if end_date is not None:\n",
        "        df = df[df['tourney_date'] <= pd.Timestamp(end_date)]\n",
        "    return df\n",
        "\n",
        "def calculate_min_matches(start_date, end_date, base_min=20):\n",
        "    \"\"\"Calculate appropriate min_matches threshold based on date range.\"\"\"\n",
        "    if start_date is None or end_date is None:\n",
        "        return base_min\n",
        "    days = (pd.Timestamp(end_date) - pd.Timestamp(start_date)).days\n",
        "    if days <= 365:\n",
        "        return max(5, base_min // 4)\n",
        "    elif days <= 365 * 2:\n",
        "        return max(8, base_min // 3)\n",
        "    elif days <= 365 * 3:\n",
        "        return max(10, base_min // 2)\n",
        "    return base_min\n",
        "\n",
        "def calculate_player_stats(matches_df, players_df, start_date=None, end_date=None):\n",
        "    \"\"\"Calculate all stats for each player.\"\"\"\n",
        "    matches_df = filter_by_date_range(matches_df, start_date, end_date)\n",
        "    min_matches = calculate_min_matches(start_date, end_date, base_min=20)\n",
        "\n",
        "    results = []\n",
        "    for _, player in players_df.iterrows():\n",
        "        pid = player['player_id']\n",
        "        name = player['full_name']\n",
        "        rank = player['rank']\n",
        "\n",
        "        # Get wins and losses\n",
        "        wins = matches_df[matches_df['winner_id'] == pid]\n",
        "        losses = matches_df[matches_df['loser_id'] == pid]\n",
        "\n",
        "        # Combine serve stats\n",
        "        w_stats = wins[['w_ace', 'w_df', 'w_svpt', 'w_1stIn', 'w_1stWon', 'w_bpSaved', 'w_bpFaced']].copy()\n",
        "        w_stats.columns = ['aces', 'df', 'svpt', '1stIn', '1stWon', 'bpSaved', 'bpFaced']\n",
        "\n",
        "        l_stats = losses[['l_ace', 'l_df', 'l_svpt', 'l_1stIn', 'l_1stWon', 'l_bpSaved', 'l_bpFaced']].copy()\n",
        "        l_stats.columns = ['aces', 'df', 'svpt', '1stIn', '1stWon', 'bpSaved', 'bpFaced']\n",
        "\n",
        "        all_stats = pd.concat([w_stats, l_stats]).dropna()\n",
        "\n",
        "        if len(all_stats) >= min_matches:\n",
        "            # Calculate ace and DF rates\n",
        "            ace_rate = (all_stats['aces'] / all_stats['svpt']).mean() * 100\n",
        "            df_rate = (all_stats['df'] / all_stats['svpt']).mean() * 100\n",
        "\n",
        "            # Calculate 1st serve stats\n",
        "            first_serve_pct = (all_stats['1stIn'] / all_stats['svpt']).mean() * 100\n",
        "            first_serve_won = (all_stats['1stWon'] / all_stats['1stIn']).mean() * 100\n",
        "\n",
        "            # Calculate break point stats (need aggregated stats)\n",
        "            bp_faced = all_stats['bpFaced'].sum()\n",
        "            bp_saved = all_stats['bpSaved'].sum()\n",
        "\n",
        "            # BP conversion (from opponent's perspective)\n",
        "            opp_bp_faced = wins['l_bpFaced'].sum() + losses['w_bpFaced'].sum()\n",
        "            opp_bp_saved = wins['l_bpSaved'].sum() + losses['w_bpSaved'].sum()\n",
        "            bp_converted = opp_bp_faced - opp_bp_saved\n",
        "\n",
        "            bp_save_pct = (bp_saved / bp_faced * 100) if bp_faced > 0 else None\n",
        "            bp_convert_pct = (bp_converted / opp_bp_faced * 100) if opp_bp_faced > 0 else None\n",
        "\n",
        "            results.append({\n",
        "                'player': name.split()[-1],  # Last name only\n",
        "                'full_name': name,\n",
        "                'rank': int(rank) if pd.notna(rank) else 99,\n",
        "                'matches': len(all_stats),\n",
        "                'ace_rate': round(ace_rate, 1),\n",
        "                'df_rate': round(df_rate, 1),\n",
        "                'first_serve_pct': round(first_serve_pct, 1),\n",
        "                'first_serve_won': round(first_serve_won, 1),\n",
        "                'bp_save_pct': round(bp_save_pct, 1) if bp_save_pct else None,\n",
        "                'bp_convert_pct': round(bp_convert_pct, 1) if bp_convert_pct else None,\n",
        "            })\n",
        "\n",
        "    df = pd.DataFrame(results)\n",
        "    if df.empty:\n",
        "        return df\n",
        "    return df.sort_values('rank').reset_index(drop=True)\n",
        "\n",
        "def calculate_surface_stats(matches_df, players_df, start_date=None, end_date=None):\n",
        "    \"\"\"Calculate serve stats by surface for each player.\"\"\"\n",
        "    matches_df = filter_by_date_range(matches_df, start_date, end_date)\n",
        "\n",
        "    results = []\n",
        "    for _, player in players_df.iterrows():\n",
        "        pid = player['player_id']\n",
        "        name = player['full_name'].split()[-1]\n",
        "        rank = player['rank']\n",
        "\n",
        "        for surface in ['Hard', 'Clay', 'Grass']:\n",
        "            surf_matches = matches_df[matches_df['surface'] == surface]\n",
        "            wins = surf_matches[surf_matches['winner_id'] == pid]\n",
        "            losses = surf_matches[surf_matches['loser_id'] == pid]\n",
        "\n",
        "            all_aces = pd.concat([wins['w_ace'], losses['l_ace']])\n",
        "            all_svpt = pd.concat([wins['w_svpt'], losses['l_svpt']])\n",
        "\n",
        "            if len(all_aces.dropna()) >= 10:\n",
        "                ace_rate = (all_aces / all_svpt).mean() * 100\n",
        "                results.append({\n",
        "                    'player': name,\n",
        "                    'rank': int(rank) if pd.notna(rank) else 99,\n",
        "                    'surface': surface,\n",
        "                    'ace_rate': round(ace_rate, 1),\n",
        "                    'matches': len(all_aces.dropna())\n",
        "                })\n",
        "\n",
        "    return pd.DataFrame(results)\n",
        "\n",
        "def calculate_tour_averages(matches_df, start_date=None, end_date=None):\n",
        "    \"\"\"Calculate tour-wide serve averages.\"\"\"\n",
        "    matches = filter_by_date_range(matches_df, start_date, end_date)\n",
        "    if matches.empty:\n",
        "        return {}\n",
        "\n",
        "    return {\n",
        "        'aces_per_match': round(matches['w_ace'].mean() + matches['l_ace'].mean(), 1),\n",
        "        'first_serve_in_pct': round((matches['w_1stIn'] / matches['w_svpt']).mean() * 100, 1),\n",
        "        'first_serve_won_pct': round((matches['w_1stWon'] / matches['w_1stIn']).mean() * 100, 1),\n",
        "        'second_serve_won_pct': round((matches['w_2ndWon'] / (matches['w_svpt'] - matches['w_1stIn'])).mean() * 100, 1),\n",
        "    }\n",
        "\n",
        "def calculate_surface_averages(matches_df, start_date=None, end_date=None):\n",
        "    \"\"\"Calculate tour averages by surface.\"\"\"\n",
        "    matches = filter_by_date_range(matches_df, start_date, end_date)\n",
        "\n",
        "    results = []\n",
        "    for surface in ['Hard', 'Clay', 'Grass']:\n",
        "        surf = matches[matches['surface'] == surface].dropna(subset=['w_ace', 'w_svpt'])\n",
        "        if len(surf) >= 50:\n",
        "            results.append({\n",
        "                'surface': surface,\n",
        "                'aces_per_match': round((surf['w_ace'] + surf['l_ace']).mean(), 1),\n",
        "                'first_won_pct': round((surf['w_1stWon'] / surf['w_1stIn']).mean() * 100, 1),\n",
        "            })\n",
        "\n",
        "    return results\n",
        "\n",
        "# Compute stats for all time periods\n",
        "def compute_all_data():\n",
        "    \"\"\"Compute all stats for export to OJS.\"\"\"\n",
        "    # Time periods\n",
        "    today = datetime.today()\n",
        "    periods = {\n",
        "        'all_time': (None, None),\n",
        "        'last_5_years': (today - timedelta(days=365*5), today),\n",
        "        'last_1_year': (today - timedelta(days=365), today),\n",
        "    }\n",
        "\n",
        "    all_data = {\n",
        "        'atp': {},\n",
        "        'wta': {},\n",
        "    }\n",
        "\n",
        "    for period_name, (start, end) in periods.items():\n",
        "        # ATP stats\n",
        "        atp_stats = calculate_player_stats(atp_serve, atp_players, start, end)\n",
        "        atp_surface = calculate_surface_stats(atp_serve, atp_players, start, end)\n",
        "        atp_avg = calculate_tour_averages(atp_serve, start, end)\n",
        "        atp_surf_avg = calculate_surface_averages(atp_serve, start, end)\n",
        "\n",
        "        # WTA stats\n",
        "        wta_stats = calculate_player_stats(wta_serve, wta_players, start, end)\n",
        "        wta_surface = calculate_surface_stats(wta_serve, wta_players, start, end)\n",
        "        wta_avg = calculate_tour_averages(wta_serve, start, end)\n",
        "        wta_surf_avg = calculate_surface_averages(wta_serve, start, end)\n",
        "\n",
        "        all_data['atp'][period_name] = {\n",
        "            'players': atp_stats.to_dict('records'),\n",
        "            'surface': atp_surface.to_dict('records'),\n",
        "            'tour_avg': atp_avg,\n",
        "            'surface_avg': atp_surf_avg,\n",
        "        }\n",
        "\n",
        "        all_data['wta'][period_name] = {\n",
        "            'players': wta_stats.to_dict('records'),\n",
        "            'surface': wta_surface.to_dict('records'),\n",
        "            'tour_avg': wta_avg,\n",
        "            'surface_avg': wta_surf_avg,\n",
        "        }\n",
        "\n",
        "    return all_data\n",
        "\n",
        "# Compute and export\n",
        "tennis_data = compute_all_data()"
      ],
      "id": "compute-stats",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: export-to-ojs\n",
        "from IPython.display import display\n",
        "ojs_define(tennis_data = tennis_data)"
      ],
      "id": "export-to-ojs",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Interactive Dashboard\n",
        "\n",
        "Use the filters below to explore serve statistics across tours and time periods.\n",
        "\n",
        "::: {.panel-sidebar}\n",
        "\n",
        "### Filters\n",
        "\n",
        "```{ojs}\n",
        "//| label: filters\n",
        "\n",
        "viewof tour = Inputs.radio([\"ATP\", \"WTA\"], {value: \"ATP\", label: \"Tour\"})\n",
        "\n",
        "viewof period = Inputs.select(\n",
        "  [\"all_time\", \"last_5_years\", \"last_1_year\"],\n",
        "  {\n",
        "    value: \"all_time\",\n",
        "    label: \"Time Period\",\n",
        "    format: x => ({\n",
        "      \"all_time\": \"All Time\",\n",
        "      \"last_5_years\": \"Last 5 Years\",\n",
        "      \"last_1_year\": \"Last 1 Year\"\n",
        "    })[x]\n",
        "  }\n",
        ")\n",
        "\n",
        "// Get available players for selected tour/period\n",
        "availablePlayers = {\n",
        "  const tourKey = tour.toLowerCase();\n",
        "  const data = tennis_data[tourKey][period];\n",
        "  return data.players.map(p => p.player);\n",
        "}\n",
        "\n",
        "viewof playerFilter = Inputs.select(\n",
        "  [\"Top 5\", \"Top 10\", \"All Players\"],\n",
        "  {value: \"Top 5\", label: \"Player Filter\"}\n",
        ")\n",
        "\n",
        "// Calculate default selected players based on filter\n",
        "defaultPlayers = {\n",
        "  const n = playerFilter === \"Top 5\" ? 5 : playerFilter === \"Top 10\" ? 10 : availablePlayers.length;\n",
        "  return availablePlayers.slice(0, n);\n",
        "}\n",
        "\n",
        "viewof selectedPlayers = Inputs.checkbox(\n",
        "  availablePlayers,\n",
        "  {value: defaultPlayers, label: \"Select Players\"}\n",
        ")\n",
        "\n",
        "viewof highlightPlayer = Inputs.select(\n",
        "  [\"None\", ...selectedPlayers],\n",
        "  {value: \"None\", label: \"Highlight Player\"}\n",
        ")\n",
        "```\n",
        "\n",
        ":::\n",
        "\n",
        "::: {.panel-fill}\n",
        "\n",
        "```{ojs}\n",
        "//| label: reactive-data\n",
        "\n",
        "// Get data for selected tour and period\n",
        "currentData = {\n",
        "  const tourKey = tour.toLowerCase();\n",
        "  return tennis_data[tourKey][period];\n",
        "}\n",
        "\n",
        "// Filter players based on selection\n",
        "filteredPlayers = currentData.players.filter(p => selectedPlayers.includes(p.player))\n",
        "\n",
        "// Calculate averages for the filtered group\n",
        "groupAverages = {\n",
        "  const players = filteredPlayers;\n",
        "  if (players.length === 0) return {};\n",
        "\n",
        "  return {\n",
        "    ace_rate: d3.mean(players, d => d.ace_rate),\n",
        "    df_rate: d3.mean(players, d => d.df_rate),\n",
        "    first_serve_pct: d3.mean(players, d => d.first_serve_pct),\n",
        "    first_serve_won: d3.mean(players, d => d.first_serve_won),\n",
        "    bp_save_pct: d3.mean(players.filter(d => d.bp_save_pct), d => d.bp_save_pct),\n",
        "    bp_convert_pct: d3.mean(players.filter(d => d.bp_convert_pct), d => d.bp_convert_pct),\n",
        "  };\n",
        "}\n",
        "\n",
        "// Surface data filtered by selected players\n",
        "filteredSurface = currentData.surface.filter(s => selectedPlayers.includes(s.player))\n",
        "\n",
        "// Colors\n",
        "tourColor = tour === \"ATP\" ? \"#1f77b4\" : \"#e377c2\"\n",
        "```\n",
        "\n",
        "### Tour Averages\n",
        "\n",
        "```{ojs}\n",
        "//| label: tour-averages\n",
        "\n",
        "html`<div style=\"display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-bottom: 2rem;\">\n",
        "  <div style=\"background: linear-gradient(135deg, ${tour === 'ATP' ? '#667eea' : '#e377c2'} 0%, ${tour === 'ATP' ? '#764ba2' : '#c44569'} 100%); padding: 1rem; border-radius: 10px; color: white; text-align: center;\">\n",
        "    <div style=\"font-size: 2rem; font-weight: bold;\">${currentData.tour_avg.aces_per_match}</div>\n",
        "    <div style=\"font-size: 0.9rem; opacity: 0.9;\">Aces/Match</div>\n",
        "  </div>\n",
        "  <div style=\"background: linear-gradient(135deg, ${tour === 'ATP' ? '#667eea' : '#e377c2'} 0%, ${tour === 'ATP' ? '#764ba2' : '#c44569'} 100%); padding: 1rem; border-radius: 10px; color: white; text-align: center;\">\n",
        "    <div style=\"font-size: 2rem; font-weight: bold;\">${currentData.tour_avg.first_serve_in_pct}%</div>\n",
        "    <div style=\"font-size: 0.9rem; opacity: 0.9;\">1st Serve In</div>\n",
        "  </div>\n",
        "  <div style=\"background: linear-gradient(135deg, ${tour === 'ATP' ? '#667eea' : '#e377c2'} 0%, ${tour === 'ATP' ? '#764ba2' : '#c44569'} 100%); padding: 1rem; border-radius: 10px; color: white; text-align: center;\">\n",
        "    <div style=\"font-size: 2rem; font-weight: bold;\">${currentData.tour_avg.first_serve_won_pct}%</div>\n",
        "    <div style=\"font-size: 0.9rem; opacity: 0.9;\">1st Serve Won</div>\n",
        "  </div>\n",
        "  <div style=\"background: linear-gradient(135deg, ${tour === 'ATP' ? '#667eea' : '#e377c2'} 0%, ${tour === 'ATP' ? '#764ba2' : '#c44569'} 100%); padding: 1rem; border-radius: 10px; color: white; text-align: center;\">\n",
        "    <div style=\"font-size: 2rem; font-weight: bold;\">${currentData.tour_avg.second_serve_won_pct}%</div>\n",
        "    <div style=\"font-size: 0.9rem; opacity: 0.9;\">2nd Serve Won</div>\n",
        "  </div>\n",
        "</div>`\n",
        "```\n",
        "\n",
        "### Ace Production: Risk vs Reward\n",
        "\n",
        "Big servers hit more aces but often double fault more too.\n",
        "\n",
        "```{ojs}\n",
        "//| label: ace-scatter\n",
        "\n",
        "Plot.plot({\n",
        "  width: 800,\n",
        "  height: 450,\n",
        "  marginRight: 60,\n",
        "  grid: true,\n",
        "  x: {label: \"Ace Rate %\", domain: [0, d3.max(filteredPlayers, d => d.ace_rate) * 1.1]},\n",
        "  y: {label: \"Double Fault Rate %\", domain: [0, d3.max(filteredPlayers, d => d.df_rate) * 1.1]},\n",
        "  marks: [\n",
        "    // Average reference lines\n",
        "    Plot.ruleX([groupAverages.ace_rate], {stroke: \"gray\", strokeDasharray: \"4,4\", strokeOpacity: 0.5}),\n",
        "    Plot.ruleY([groupAverages.df_rate], {stroke: \"gray\", strokeDasharray: \"4,4\", strokeOpacity: 0.5}),\n",
        "    // Points\n",
        "    Plot.dot(filteredPlayers, {\n",
        "      x: \"ace_rate\",\n",
        "      y: \"df_rate\",\n",
        "      r: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? 12 : 8,\n",
        "      fill: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"gold\" : tourColor,\n",
        "      stroke: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"darkred\" : \"white\",\n",
        "      strokeWidth: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? 3 : 1,\n",
        "      title: d => `${d.player} (#${d.rank})\\nAce Rate: ${d.ace_rate}%\\nDF Rate: ${d.df_rate}%\\nMatches: ${d.matches}`,\n",
        "    }),\n",
        "    // Labels\n",
        "    Plot.text(filteredPlayers, {\n",
        "      x: \"ace_rate\",\n",
        "      y: \"df_rate\",\n",
        "      text: \"player\",\n",
        "      dy: -12,\n",
        "      fontSize: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? 12 : 10,\n",
        "      fontWeight: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"bold\" : \"normal\",\n",
        "      fill: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"darkred\" : \"black\",\n",
        "    }),\n",
        "  ]\n",
        "})\n",
        "```\n",
        "\n",
        "### First Serve: Accuracy vs Effectiveness\n",
        "\n",
        "Getting the first serve in is important, but winning the point matters more.\n",
        "\n",
        "```{ojs}\n",
        "//| label: first-serve-scatter\n",
        "\n",
        "Plot.plot({\n",
        "  width: 800,\n",
        "  height: 450,\n",
        "  marginRight: 60,\n",
        "  grid: true,\n",
        "  x: {label: \"1st Serve In %\", domain: [d3.min(filteredPlayers, d => d.first_serve_pct) * 0.95, d3.max(filteredPlayers, d => d.first_serve_pct) * 1.02]},\n",
        "  y: {label: \"1st Serve Won %\", domain: [d3.min(filteredPlayers, d => d.first_serve_won) * 0.95, d3.max(filteredPlayers, d => d.first_serve_won) * 1.02]},\n",
        "  marks: [\n",
        "    // Average reference lines\n",
        "    Plot.ruleX([groupAverages.first_serve_pct], {stroke: \"gray\", strokeDasharray: \"4,4\", strokeOpacity: 0.5}),\n",
        "    Plot.ruleY([groupAverages.first_serve_won], {stroke: \"gray\", strokeDasharray: \"4,4\", strokeOpacity: 0.5}),\n",
        "    // Points\n",
        "    Plot.dot(filteredPlayers, {\n",
        "      x: \"first_serve_pct\",\n",
        "      y: \"first_serve_won\",\n",
        "      r: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? 12 : 8,\n",
        "      fill: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"gold\" : tourColor,\n",
        "      stroke: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"darkred\" : \"white\",\n",
        "      strokeWidth: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? 3 : 1,\n",
        "      title: d => `${d.player} (#${d.rank})\\n1st Serve In: ${d.first_serve_pct}%\\n1st Serve Won: ${d.first_serve_won}%`,\n",
        "    }),\n",
        "    // Labels\n",
        "    Plot.text(filteredPlayers, {\n",
        "      x: \"first_serve_pct\",\n",
        "      y: \"first_serve_won\",\n",
        "      text: \"player\",\n",
        "      dy: -12,\n",
        "      fontSize: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? 12 : 10,\n",
        "      fontWeight: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"bold\" : \"normal\",\n",
        "      fill: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"darkred\" : \"black\",\n",
        "    }),\n",
        "  ]\n",
        "})\n",
        "```\n",
        "\n",
        "### Break Point Performance\n",
        "\n",
        "Clutch players both save break points on serve and convert them on return.\n",
        "\n",
        "```{ojs}\n",
        "//| label: bp-scatter\n",
        "\n",
        "// Filter to players with BP data\n",
        "bpPlayers = filteredPlayers.filter(p => p.bp_save_pct && p.bp_convert_pct)\n",
        "\n",
        "Plot.plot({\n",
        "  width: 800,\n",
        "  height: 450,\n",
        "  marginRight: 60,\n",
        "  grid: true,\n",
        "  x: {label: \"BP Save %\", domain: [d3.min(bpPlayers, d => d.bp_save_pct) * 0.95, d3.max(bpPlayers, d => d.bp_save_pct) * 1.02]},\n",
        "  y: {label: \"BP Convert %\", domain: [d3.min(bpPlayers, d => d.bp_convert_pct) * 0.95, d3.max(bpPlayers, d => d.bp_convert_pct) * 1.02]},\n",
        "  marks: [\n",
        "    // Average reference lines\n",
        "    Plot.ruleX([groupAverages.bp_save_pct], {stroke: \"gray\", strokeDasharray: \"4,4\", strokeOpacity: 0.5}),\n",
        "    Plot.ruleY([groupAverages.bp_convert_pct], {stroke: \"gray\", strokeDasharray: \"4,4\", strokeOpacity: 0.5}),\n",
        "    // Points\n",
        "    Plot.dot(bpPlayers, {\n",
        "      x: \"bp_save_pct\",\n",
        "      y: \"bp_convert_pct\",\n",
        "      r: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? 12 : 8,\n",
        "      fill: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"gold\" : tourColor,\n",
        "      stroke: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"darkred\" : \"white\",\n",
        "      strokeWidth: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? 3 : 1,\n",
        "      title: d => `${d.player} (#${d.rank})\\nBP Save: ${d.bp_save_pct}%\\nBP Convert: ${d.bp_convert_pct}%`,\n",
        "    }),\n",
        "    // Labels\n",
        "    Plot.text(bpPlayers, {\n",
        "      x: \"bp_save_pct\",\n",
        "      y: \"bp_convert_pct\",\n",
        "      text: \"player\",\n",
        "      dy: -12,\n",
        "      fontSize: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? 12 : 10,\n",
        "      fontWeight: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"bold\" : \"normal\",\n",
        "      fill: d => highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"darkred\" : \"black\",\n",
        "    }),\n",
        "  ]\n",
        "})\n",
        "```\n",
        "\n",
        "### Surface Analysis\n",
        "\n",
        "Grass favors servers (fast, low bounce). Clay neutralizes the serve (slow, high bounce).\n",
        "\n",
        "```{ojs}\n",
        "//| label: surface-chart\n",
        "\n",
        "// Surface averages bar chart\n",
        "surfaceColors = ({Hard: \"#1f77b4\", Clay: \"#d62728\", Grass: \"#2ca02c\"})\n",
        "\n",
        "Plot.plot({\n",
        "  width: 700,\n",
        "  height: 350,\n",
        "  marginBottom: 40,\n",
        "  x: {label: \"Surface\", padding: 0.3},\n",
        "  y: {label: \"Aces per Match\", domain: [0, d3.max(currentData.surface_avg, d => d.aces_per_match) * 1.2]},\n",
        "  marks: [\n",
        "    Plot.barY(currentData.surface_avg, {\n",
        "      x: \"surface\",\n",
        "      y: \"aces_per_match\",\n",
        "      fill: d => surfaceColors[d.surface],\n",
        "      title: d => `${d.surface}\\nAces/Match: ${d.aces_per_match}\\n1st Won: ${d.first_won_pct}%`\n",
        "    }),\n",
        "    Plot.text(currentData.surface_avg, {\n",
        "      x: \"surface\",\n",
        "      y: \"aces_per_match\",\n",
        "      text: d => d.aces_per_match,\n",
        "      dy: -8,\n",
        "      fontSize: 14,\n",
        "      fontWeight: \"bold\"\n",
        "    })\n",
        "  ]\n",
        "})\n",
        "```\n",
        "\n",
        "### Player Surface Profiles\n",
        "\n",
        "How does each player's serve performance vary across surfaces?\n",
        "\n",
        "```{ojs}\n",
        "//| label: surface-heatmap\n",
        "\n",
        "// Pivot surface data for heatmap\n",
        "surfacePivot = {\n",
        "  const players = [...new Set(filteredSurface.map(d => d.player))];\n",
        "  const surfaces = [\"Hard\", \"Clay\", \"Grass\"];\n",
        "\n",
        "  // Create pivot with player/rank pairs\n",
        "  const result = [];\n",
        "  for (const player of players) {\n",
        "    const playerData = filteredSurface.filter(d => d.player === player);\n",
        "    if (playerData.length > 0) {\n",
        "      const row = {\n",
        "        player: player,\n",
        "        rank: playerData[0].rank\n",
        "      };\n",
        "      for (const surface of surfaces) {\n",
        "        const surfData = playerData.find(d => d.surface === surface);\n",
        "        row[surface] = surfData ? surfData.ace_rate : null;\n",
        "      }\n",
        "      result.push(row);\n",
        "    }\n",
        "  }\n",
        "\n",
        "  // Sort by rank and take top 12\n",
        "  return result.sort((a, b) => a.rank - b.rank).slice(0, 12);\n",
        "}\n",
        "\n",
        "// Flatten for heatmap\n",
        "heatmapData = {\n",
        "  const data = [];\n",
        "  const surfaces = [\"Hard\", \"Clay\", \"Grass\"];\n",
        "  for (const row of surfacePivot) {\n",
        "    for (const surface of surfaces) {\n",
        "      if (row[surface] !== null) {\n",
        "        data.push({\n",
        "          player: row.player,\n",
        "          surface: surface,\n",
        "          ace_rate: row[surface]\n",
        "        });\n",
        "      }\n",
        "    }\n",
        "  }\n",
        "  return data;\n",
        "}\n",
        "\n",
        "Plot.plot({\n",
        "  width: 600,\n",
        "  height: 400,\n",
        "  marginLeft: 80,\n",
        "  marginBottom: 40,\n",
        "  color: {\n",
        "    scheme: tour === \"ATP\" ? \"blues\" : \"RdPu\",\n",
        "    legend: true,\n",
        "    label: \"Ace Rate %\"\n",
        "  },\n",
        "  x: {label: \"Surface\", padding: 0.1},\n",
        "  y: {label: null, padding: 0.1},\n",
        "  marks: [\n",
        "    Plot.cell(heatmapData, {\n",
        "      x: \"surface\",\n",
        "      y: \"player\",\n",
        "      fill: \"ace_rate\",\n",
        "      title: d => `${d.player}\\n${d.surface}: ${d.ace_rate}%`\n",
        "    }),\n",
        "    Plot.text(heatmapData, {\n",
        "      x: \"surface\",\n",
        "      y: \"player\",\n",
        "      text: d => d.ace_rate ? `${d.ace_rate}%` : \"\",\n",
        "      fill: d => d.ace_rate > 8 ? \"white\" : \"black\",\n",
        "      fontSize: 11\n",
        "    })\n",
        "  ]\n",
        "})\n",
        "```\n",
        "\n",
        ":::\n",
        "\n",
        "## Highlighted Player Comparison\n",
        "\n",
        "```{ojs}\n",
        "//| label: highlight-comparison\n",
        "\n",
        "highlightedStats = {\n",
        "  if (highlightPlayer === \"None\") return null;\n",
        "  return filteredPlayers.find(p => p.player === highlightPlayer);\n",
        "}\n",
        "\n",
        "html`${highlightPlayer !== \"None\" && highlightedStats ? html`\n",
        "<div style=\"background: #f8f9fa; padding: 1.5rem; border-radius: 10px; margin: 1rem 0;\">\n",
        "  <h4 style=\"margin-top: 0;\">${highlightedStats.full_name} (#${highlightedStats.rank}) vs Selected Players</h4>\n",
        "  <div style=\"display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;\">\n",
        "    <div style=\"background: white; padding: 1rem; border-radius: 8px; border-left: 4px solid ${highlightedStats.ace_rate > groupAverages.ace_rate ? 'green' : 'red'};\">\n",
        "      <div style=\"font-size: 0.75rem; color: #666;\">Ace Rate</div>\n",
        "      <div style=\"font-size: 1.4rem; font-weight: bold;\">${highlightedStats.ace_rate}%</div>\n",
        "      <div style=\"font-size: 0.8rem; color: ${highlightedStats.ace_rate > groupAverages.ace_rate ? 'green' : 'red'};\">\n",
        "        ${(highlightedStats.ace_rate - groupAverages.ace_rate).toFixed(1)}% vs avg (${groupAverages.ace_rate.toFixed(1)}%)\n",
        "      </div>\n",
        "    </div>\n",
        "    <div style=\"background: white; padding: 1rem; border-radius: 8px; border-left: 4px solid ${highlightedStats.first_serve_won > groupAverages.first_serve_won ? 'green' : 'red'};\">\n",
        "      <div style=\"font-size: 0.75rem; color: #666;\">1st Serve Won</div>\n",
        "      <div style=\"font-size: 1.4rem; font-weight: bold;\">${highlightedStats.first_serve_won}%</div>\n",
        "      <div style=\"font-size: 0.8rem; color: ${highlightedStats.first_serve_won > groupAverages.first_serve_won ? 'green' : 'red'};\">\n",
        "        ${(highlightedStats.first_serve_won - groupAverages.first_serve_won).toFixed(1)}% vs avg (${groupAverages.first_serve_won.toFixed(1)}%)\n",
        "      </div>\n",
        "    </div>\n",
        "    <div style=\"background: white; padding: 1rem; border-radius: 8px; border-left: 4px solid ${highlightedStats.bp_save_pct > groupAverages.bp_save_pct ? 'green' : 'red'};\">\n",
        "      <div style=\"font-size: 0.75rem; color: #666;\">BP Save</div>\n",
        "      <div style=\"font-size: 1.4rem; font-weight: bold;\">${highlightedStats.bp_save_pct}%</div>\n",
        "      <div style=\"font-size: 0.8rem; color: ${highlightedStats.bp_save_pct > groupAverages.bp_save_pct ? 'green' : 'red'};\">\n",
        "        ${(highlightedStats.bp_save_pct - groupAverages.bp_save_pct).toFixed(1)}% vs avg (${groupAverages.bp_save_pct.toFixed(1)}%)\n",
        "      </div>\n",
        "    </div>\n",
        "  </div>\n",
        "</div>\n",
        "` : html`<p style=\"color: #666; font-style: italic;\">Select a player to highlight from the sidebar to see detailed comparison.</p>`}`\n",
        "```\n",
        "\n",
        "## Key Takeaways\n",
        "\n",
        "- **Winners outserve losers** across all metrics, with the biggest gaps in 1st serve win % and break point save %\n",
        "- **ATP players hit 2x more aces** than WTA players on average\n",
        "- **Break point save %** is the most predictive stat - it combines serving ability with clutch performance\n",
        "- **Surface matters**: Grass produces the most aces; clay neutralizes serve advantages\n",
        "\n",
        "---\n",
        "\n",
        "*Data source: [Tennis Abstract](http://www.tennisabstract.com/) | Dashboard built with Quarto and Observable JS*"
      ],
      "id": "eb8130fd"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/azaidi/anaconda3/envs/fastdl/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}