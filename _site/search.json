[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Ali Zaidi",
    "section": "",
    "text": "Iâ€™m a Product Leader and Applied AI Engineer with a passion for building data-driven products that solve real problems. With experience spanning startups and enterprise environments, I specialize in bridging the gap between cutting-edge technical solutions and strategic product vision. I believe the best products emerge when deep technical understanding meets genuine user empathy."
  },
  {
    "objectID": "about.html#what-i-do",
    "href": "about.html#what-i-do",
    "title": "Ali Zaidi",
    "section": "What I Do",
    "text": "What I Do\nI work at the intersection of product strategy and hands-on engineering. Whether itâ€™s defining a product roadmap, architecting an ML pipeline, or diving into code to prototype a new feature, Iâ€™m comfortable operating across the full stack of product development. My approach combines rigorous data analysis with iterative experimentation to build products that users love."
  },
  {
    "objectID": "about.html#core-expertise",
    "href": "about.html#core-expertise",
    "title": "Ali Zaidi",
    "section": "Core Expertise",
    "text": "Core Expertise\n\n\n\n\nProduct Leadership\n\n\nDefining product vision, building roadmaps, and aligning cross-functional teams. Experienced in translating complex technical capabilities into clear value propositions for stakeholders and customers.\n\n\n\n\n\n\nApplied AI & ML\n\n\nBuilding production-grade ML systems from research to deployment. Deep experience with PyTorch, TensorFlow, and modern LLM frameworks. Focus on practical solutions that scale.\n\n\n\n\n\n\nFull Stack Data\n\n\nEnd-to-end ownership from data ingestion and transformation to analysis and visualization. Building reliable pipelines that turn raw data into actionable insights.\n\n\n\n\n\n\nData Science\n\n\nExpertise in Computer Vision, NLP, and generative AI. Strong foundation in statistical modeling, experiment design, and turning ambiguous problems into measurable solutions.\n\n\n\n\n\n\nSoftware Engineering\n\n\nProduction-quality code with modern practices: RESTful APIs, CI/CD pipelines, containerization with Docker, and maintainable Python packages. Code thatâ€™s built to last.\n\n\n\n\n\n\nCloud & Infrastructure\n\n\nDesigning and deploying scalable systems on AWS and other cloud platforms. Experience with HPC/SLURM clusters for compute-intensive workloads and cost-optimized architectures."
  },
  {
    "objectID": "about.html#background",
    "href": "about.html#background",
    "title": "Ali Zaidi",
    "section": "Background",
    "text": "Background\nMy journey in tech has taken me through diverse roles where Iâ€™ve consistently focused on using data and technology to drive impact. Iâ€™ve led product initiatives from conception to launch, built ML systems processing millions of data points, and mentored teams on best practices for scalable software development. Iâ€™m driven by curiosity and a desire to continuously learnâ€”whether thatâ€™s exploring the latest advances in AI or understanding a new problem domain."
  },
  {
    "objectID": "about.html#lets-connect",
    "href": "about.html#lets-connect",
    "title": "Ali Zaidi",
    "section": "Letâ€™s Connect",
    "text": "Letâ€™s Connect\nIâ€™m always interested in discussing new opportunities, collaborating on interesting projects, or just chatting about the latest in AI and product development. Feel free to reach out through any of the links above."
  },
  {
    "objectID": "posts/quarto_tutorial/blog_tutorial.html",
    "href": "posts/quarto_tutorial/blog_tutorial.html",
    "title": "Making a blog",
    "section": "",
    "text": "1 Why would you ever want to write a blog?\nCreating a blog is often hailed as an essential step in ones machine learning journey â€“ but this can most likely be abstracted to ones software development journey.  When I started learning how to code a few years ago, the idea of creating a blog while ALSO trying to learn all these new things seemed daunting. In hindsight, it would have been appropriate to start right away. Most of what I worked on or touched has basically disappeared into the ether. Sure, thereâ€™s some neat kaggle notebooks I could point people to, but overall the delivery mechanism just isnâ€™t there. How would I even go about showing this to someone? Hereâ€™s a bunch of URLs to Kaggle notebooks and Github repos\n\n\n\n2 Where would you even begin to start a blog?\nIf you wanted to bypass doing any setup work - you could create profile on Medium (or something similar) and start posting there. While Iâ€™m sure itâ€™s an excellent option, creating your own blog provides the opportunity to customize everything and be in control. At some point (a few years ago) I decided I should heed this advice, but I also convinced myself that I needed to create the website from scratch with Django. After about a day or two of (what felt like) banging my head, I came to my senses and gave up. \nLuckily, with Quarto things couldnâ€™t be easier! This post is based on the work of other wonderful posts that I found on the Fast.AI forums (one) (two) â€“ along with some perusing of the Quarto docs.\n\n\n3 How can you build one with Quarto?"
  },
  {
    "objectID": "posts/tennis-eda/tennis-eda.html",
    "href": "posts/tennis-eda/tennis-eda.html",
    "title": "Tennis Dashboard: Top 10 Analysis",
    "section": "",
    "text": "Tennis Top 10 Players\n\n\n\n\n\nDashboard Setup\nimport pandas as pd\nimport numpy as np\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom datetime import datetime\nimport warnings\nwarnings.filterwarnings('ignore')\n\nfrom IPython.display import display, HTML, Markdown\nfrom itables import init_notebook_mode, show\ninit_notebook_mode(all_interactive=True)\n\nimport plotly.io as pio\npio.templates.default = 'plotly_white'\n\n# Load data\nDATA_PATH = '../../data/top10'\natp_players = pd.read_csv(f'{DATA_PATH}/atp/atp_top10_players.csv')\natp_rankings = pd.read_csv(f'{DATA_PATH}/atp/atp_top10_rankings.csv')\natp_matches = pd.read_csv(f'{DATA_PATH}/atp/atp_top10_matches.csv')\nwta_players = pd.read_csv(f'{DATA_PATH}/wta/wta_top10_players.csv')\nwta_rankings = pd.read_csv(f'{DATA_PATH}/wta/wta_top10_rankings.csv')\nwta_matches = pd.read_csv(f'{DATA_PATH}/wta/wta_top10_matches.csv')\n\n# Process data\ndef parse_dob(dob):\n    if pd.isna(dob): return None\n    try: return datetime.strptime(str(int(dob)), '%Y%m%d')\n    except: return None\n\ndef calculate_age(dob):\n    if dob is None: return None\n    return (datetime(2024, 12, 30) - dob).days / 365.25\n\nfor df in [atp_players, wta_players]:\n    df['dob_parsed'] = df['dob'].apply(parse_dob)\n    df['age'] = df['dob_parsed'].apply(calculate_age)\n    df['full_name'] = df['name_first'] + ' ' + df['name_last']\n\natp_players['tour'], wta_players['tour'] = 'ATP', 'WTA'\natp_matches['tour'], wta_matches['tour'] = 'ATP', 'WTA'\n\n# Parse dates\natp_rankings['date'] = pd.to_datetime(atp_rankings['ranking_date'].astype(str), format='%Y%m%d')\natp_rankings = atp_rankings.merge(atp_players[['player_id', 'full_name']], left_on='player', right_on='player_id')\nwta_rankings['date'] = pd.to_datetime(wta_rankings['ranking_date'].astype(str), format='%Y%m%d')\nwta_rankings = wta_rankings.merge(wta_players[['player_id', 'full_name']], left_on='player', right_on='player_id')\n\natp_matches['tourney_date'] = pd.to_datetime(atp_matches['tourney_date'].astype(str), format='%Y%m%d')\nwta_matches['tourney_date'] = pd.to_datetime(wta_matches['tourney_date'].astype(str), format='%Y%m%d')\n\nall_players = pd.concat([atp_players, wta_players], ignore_index=True)\n\n\n\nQuick Stats\nKey metrics from our dataset covering the Top 10 ATP and WTA players as of December 30, 2024.\n\n\nGenerate KPI cards\n# Calculate key metrics\ntotal_matches = len(atp_matches) + len(wta_matches)\natp_top_ranked = atp_players.loc[atp_rankings[atp_rankings['rank'] == 1]['player_id'].mode().iloc[0] == atp_players['player_id'], 'full_name'].iloc[0] if len(atp_rankings[atp_rankings['rank'] == 1]) &gt; 0 else 'N/A'\n\n# Weeks at #1 calculations\natp_weeks_1 = atp_rankings[atp_rankings['rank'] == 1].groupby('full_name').size().max()\nwta_weeks_1 = wta_rankings[wta_rankings['rank'] == 1].groupby('full_name').size().max()\n\nkpi_html = f'''\n&lt;div style=\"display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin: 20px 0;\"&gt;\n    &lt;div style=\"background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 25px; border-radius: 15px; text-align: center; color: white; box-shadow: 0 4px 15px rgba(0,0,0,0.1);\"&gt;\n        &lt;div style=\"font-size: 2.5em; font-weight: bold;\"&gt;{total_matches:,}&lt;/div&gt;\n        &lt;div style=\"font-size: 0.9em; opacity: 0.9;\"&gt;Total Matches Analyzed&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div style=\"background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); padding: 25px; border-radius: 15px; text-align: center; color: white; box-shadow: 0 4px 15px rgba(0,0,0,0.1);\"&gt;\n        &lt;div style=\"font-size: 2.5em; font-weight: bold;\"&gt;20&lt;/div&gt;\n        &lt;div style=\"font-size: 0.9em; opacity: 0.9;\"&gt;Elite Players Tracked&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div style=\"background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); padding: 25px; border-radius: 15px; text-align: center; color: white; box-shadow: 0 4px 15px rgba(0,0,0,0.1);\"&gt;\n        &lt;div style=\"font-size: 2.5em; font-weight: bold;\"&gt;{atp_weeks_1}&lt;/div&gt;\n        &lt;div style=\"font-size: 0.9em; opacity: 0.9;\"&gt;ATP Most Weeks at #1&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div style=\"background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); padding: 25px; border-radius: 15px; text-align: center; color: white; box-shadow: 0 4px 15px rgba(0,0,0,0.1);\"&gt;\n        &lt;div style=\"font-size: 2.5em; font-weight: bold;\"&gt;{wta_weeks_1}&lt;/div&gt;\n        &lt;div style=\"font-size: 0.9em; opacity: 0.9;\"&gt;WTA Most Weeks at #1&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n'''\ndisplay(HTML(kpi_html))\n\n\n\n\n    \n        11,552\n        Total Matches Analyzed\n    \n    \n        20\n        Elite Players Tracked\n    \n    \n        377\n        ATP Most Weeks at #1\n    \n    \n        120\n        WTA Most Weeks at #1\n    \n\n\n\n\n\nPlayer Overview\n\nATP TourWTA Tour\n\n\n\n\nATP Player Overview\n# Calculate records\ndef calculate_record(matches_df, players_df):\n    records = []\n    for _, player in players_df.iterrows():\n        pid = player['player_id']\n        wins = len(matches_df[matches_df['winner_id'] == pid])\n        losses = len(matches_df[matches_df['loser_id'] == pid])\n        total = wins + losses\n        win_pct = (wins / total * 100) if total &gt; 0 else 0\n        records.append({\n            'Player': player['full_name'],\n            'Country': player['ioc'],\n            'Age': round(player['age'], 1) if player['age'] else None,\n            'Height': player['height'],\n            'Wins': wins,\n            'Losses': losses,\n            'Win %': round(win_pct, 1)\n        })\n    return pd.DataFrame(records).sort_values('Win %', ascending=False)\n\natp_overview = calculate_record(atp_matches, atp_players)\n\n# Create visualization\nfig = go.Figure()\natp_sorted = atp_overview.sort_values('Win %', ascending=True)\ncolors = ['#FFD700' if x &gt;= 80 else '#2196F3' for x in atp_sorted['Win %']]\n\nfig.add_trace(go.Bar(\n    x=atp_sorted['Win %'],\n    y=atp_sorted['Player'],\n    orientation='h',\n    marker_color=colors,\n    text=[f\"{x}%\" for x in atp_sorted['Win %']],\n    textposition='outside',\n    hovertemplate='&lt;b&gt;%{y}&lt;/b&gt;&lt;br&gt;Win Rate: %{x}%&lt;br&gt;Record: %{customdata[0]}-%{customdata[1]}&lt;extra&gt;&lt;/extra&gt;',\n    customdata=atp_sorted[['Wins', 'Losses']].values\n))\n\nfig.add_vline(x=80, line_dash='dash', line_color='gold', annotation_text='Elite (80%)')\n\nfig.update_layout(\n    title=dict(text='ATP Top 10 Career Win Rate', font=dict(size=20)),\n    height=450,\n    xaxis_title='Win Percentage',\n    margin=dict(l=150, r=50, t=60, b=50),\n    plot_bgcolor='rgba(0,0,0,0)',\n    paper_bgcolor='rgba(0,0,0,0)'\n)\nfig.show()\n\nprint(\"\\nðŸ“Š Full Player Data (sortable):\")\nshow(atp_overview, classes=\"display compact\", scrollY=\"300px\")\n\n\n        \n        \n        \n\n\n                            \n                                            \n\n\n\nðŸ“Š Full Player Data (sortable):\n\n\n\n\n    \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n   \n    \n      \n  \n        \n    \n    \n  \n        \n    \n    \n  \n        \n    \n      \n  \n        \n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n        \n    \n\n\n    Loading ITables v2.6.2 from the init_notebook_mode cell...\n    (need help?)\n    \n\n\n\n\n\n\n\nWTA Player Overview\nwta_overview = calculate_record(wta_matches, wta_players)\n\nfig = go.Figure()\nwta_sorted = wta_overview.sort_values('Win %', ascending=True)\ncolors = ['#FFD700' if x &gt;= 80 else '#E91E63' for x in wta_sorted['Win %']]\n\nfig.add_trace(go.Bar(\n    x=wta_sorted['Win %'],\n    y=wta_sorted['Player'],\n    orientation='h',\n    marker_color=colors,\n    text=[f\"{x}%\" for x in wta_sorted['Win %']],\n    textposition='outside',\n    hovertemplate='&lt;b&gt;%{y}&lt;/b&gt;&lt;br&gt;Win Rate: %{x}%&lt;br&gt;Record: %{customdata[0]}-%{customdata[1]}&lt;extra&gt;&lt;/extra&gt;',\n    customdata=wta_sorted[['Wins', 'Losses']].values\n))\n\nfig.add_vline(x=80, line_dash='dash', line_color='gold', annotation_text='Elite (80%)')\n\nfig.update_layout(\n    title=dict(text='WTA Top 10 Career Win Rate', font=dict(size=20)),\n    height=450,\n    xaxis_title='Win Percentage',\n    margin=dict(l=150, r=50, t=60, b=50),\n    plot_bgcolor='rgba(0,0,0,0)',\n    paper_bgcolor='rgba(0,0,0,0)'\n)\nfig.show()\n\nprint(\"\\nðŸ“Š Full Player Data (sortable):\")\nshow(wta_overview, classes=\"display compact\", scrollY=\"300px\")\n\n\n                            \n                                            \n\n\n\nðŸ“Š Full Player Data (sortable):\n\n\n\n\n    \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n   \n    \n      \n  \n        \n    \n    \n  \n        \n    \n    \n  \n        \n    \n      \n  \n        \n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n        \n    \n\n\n    Loading ITables v2.6.2 from the init_notebook_mode cell...\n    (need help?)\n    \n\n\n\n\n\n\n\n\nRankings History\nTrack how these players have risen through the rankings. Use the range slider and year buttons to zoom into specific time periods. Click on player names in the legend to toggle visibility.\n\nATP RankingsWTA Rankings\n\n\n\n\nATP Rankings History\nfig = px.line(\n    atp_rankings.sort_values('date'),\n    x='date', y='rank', color='full_name',\n    labels={'date': 'Year', 'rank': 'Ranking', 'full_name': 'Player'},\n    hover_data={'date': '|%B %Y', 'rank': True}\n)\n\nfig.update_yaxes(autorange='reversed', range=[150, 1])\nfig.add_hline(y=10, line_dash='dash', line_color='gray', opacity=0.5)\nfig.add_hline(y=1, line_dash='dash', line_color='gold', opacity=0.7)\n\nfig.update_layout(\n    title=dict(text='ATP Rankings Journey', font=dict(size=20)),\n    height=550,\n    legend=dict(orientation='h', yanchor='bottom', y=-0.25, xanchor='center', x=0.5),\n    xaxis=dict(\n        rangeselector=dict(\n            buttons=list([\n                dict(count=1, label='1Y', step='year', stepmode='backward'),\n                dict(count=5, label='5Y', step='year', stepmode='backward'),\n                dict(count=10, label='10Y', step='year', stepmode='backward'),\n                dict(step='all', label='All')\n            ]),\n            bgcolor='rgba(150,150,150,0.1)',\n            activecolor='#667eea'\n        ),\n        rangeslider=dict(visible=True, thickness=0.05),\n        type='date'\n    ),\n    plot_bgcolor='rgba(0,0,0,0)',\n    hovermode='x unified'\n)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\nWTA Rankings History\nfig = px.line(\n    wta_rankings.sort_values('date'),\n    x='date', y='rank', color='full_name',\n    labels={'date': 'Year', 'rank': 'Ranking', 'full_name': 'Player'},\n    hover_data={'date': '|%B %Y', 'rank': True}\n)\n\nfig.update_yaxes(autorange='reversed', range=[150, 1])\nfig.add_hline(y=10, line_dash='dash', line_color='gray', opacity=0.5)\nfig.add_hline(y=1, line_dash='dash', line_color='gold', opacity=0.7)\n\nfig.update_layout(\n    title=dict(text='WTA Rankings Journey', font=dict(size=20)),\n    height=550,\n    legend=dict(orientation='h', yanchor='bottom', y=-0.25, xanchor='center', x=0.5),\n    xaxis=dict(\n        rangeselector=dict(\n            buttons=list([\n                dict(count=1, label='1Y', step='year', stepmode='backward'),\n                dict(count=5, label='5Y', step='year', stepmode='backward'),\n                dict(step='all', label='All')\n            ]),\n            bgcolor='rgba(150,150,150,0.1)',\n            activecolor='#E91E63'\n        ),\n        rangeslider=dict(visible=True, thickness=0.05),\n        type='date'\n    ),\n    plot_bgcolor='rgba(0,0,0,0)',\n    hovermode='x unified'\n)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\n\nSurface Performance\nTennis is played on different surfacesâ€”Hard, Clay, and Grassâ€”and players often excel on specific surfaces. Explore the heatmaps and radar charts below.\n\nPerformance HeatmapsPlayer Profiles (Radar)\n\n\n\n\nSurface Performance Heatmaps\ndef surface_record(matches_df, players_df):\n    results = []\n    for _, player in players_df.iterrows():\n        pid, name = player['player_id'], player['full_name']\n        row = {'Player': name}\n        for surface in ['Hard', 'Clay', 'Grass']:\n            surface_matches = matches_df[matches_df['surface'] == surface]\n            wins = len(surface_matches[surface_matches['winner_id'] == pid])\n            losses = len(surface_matches[surface_matches['loser_id'] == pid])\n            total = wins + losses\n            row[surface] = round(wins / total * 100, 1) if total &gt;= 10 else None\n        results.append(row)\n    return pd.DataFrame(results)\n\natp_surface = surface_record(atp_matches, atp_players)\nwta_surface = surface_record(wta_matches, wta_players)\n\nfig = make_subplots(rows=1, cols=2, subplot_titles=('ATP Surface Mastery', 'WTA Surface Mastery'), horizontal_spacing=0.12)\n\natp_heat = atp_surface.set_index('Player')[['Hard', 'Clay', 'Grass']].dropna(how='all')\nwta_heat = wta_surface.set_index('Player')[['Hard', 'Clay', 'Grass']].dropna(how='all')\n\nfig.add_trace(go.Heatmap(\n    z=atp_heat.values, x=atp_heat.columns, y=atp_heat.index,\n    colorscale='Blues', zmin=50, zmax=95,\n    text=[[f'{v:.1f}%' if pd.notna(v) else '' for v in row] for row in atp_heat.values],\n    texttemplate='%{text}', textfont=dict(size=11),\n    hovertemplate='%{y}&lt;br&gt;%{x}: %{z:.1f}%&lt;extra&gt;&lt;/extra&gt;',\n    showscale=False\n), row=1, col=1)\n\nfig.add_trace(go.Heatmap(\n    z=wta_heat.values, x=wta_heat.columns, y=wta_heat.index,\n    colorscale='RdPu', zmin=50, zmax=95,\n    text=[[f'{v:.1f}%' if pd.notna(v) else '' for v in row] for row in wta_heat.values],\n    texttemplate='%{text}', textfont=dict(size=11),\n    hovertemplate='%{y}&lt;br&gt;%{x}: %{z:.1f}%&lt;extra&gt;&lt;/extra&gt;',\n    colorbar=dict(title='Win %', x=1.02, ticksuffix='%')\n), row=1, col=2)\n\nfig.update_layout(height=500, title_text='Win Percentage by Surface (min. 10 matches)')\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\nSurface Profile Radar Charts\n# ATP Radar\natp_top = ['Novak Djokovic', 'Carlos Alcaraz', 'Jannik Sinner', 'Alexander Zverev']\ncategories = ['Hard', 'Clay', 'Grass', 'Hard']\n\nfig = make_subplots(rows=1, cols=2, specs=[[{'type': 'polar'}, {'type': 'polar'}]],\n                    subplot_titles=('ATP Top Players', 'WTA Top Players'))\n\ncolors_atp = px.colors.qualitative.Set2[:4]\nfor i, player in enumerate(atp_top):\n    pdata = atp_surface[atp_surface['Player'] == player]\n    if not pdata.empty:\n        values = [pdata['Hard'].values[0], pdata['Clay'].values[0], pdata['Grass'].values[0], pdata['Hard'].values[0]]\n        fig.add_trace(go.Scatterpolar(\n            r=values, theta=categories, name=player.split()[-1],\n            fill='toself', opacity=0.6, line=dict(color=colors_atp[i])\n        ), row=1, col=1)\n\n# WTA Radar\nwta_top = ['Iga Swiatek', 'Aryna Sabalenka', 'Coco Gauff', 'Elena Rybakina']\ncolors_wta = px.colors.qualitative.Pastel[:4]\nfor i, player in enumerate(wta_top):\n    pdata = wta_surface[wta_surface['Player'] == player]\n    if not pdata.empty:\n        values = [pdata['Hard'].values[0], pdata['Clay'].values[0], pdata['Grass'].values[0], pdata['Hard'].values[0]]\n        fig.add_trace(go.Scatterpolar(\n            r=values, theta=categories, name=player.split()[-1],\n            fill='toself', opacity=0.6, line=dict(color=colors_wta[i])\n        ), row=1, col=2)\n\nfig.update_polars(radialaxis=dict(visible=True, range=[40, 100]))\nfig.update_layout(height=450, showlegend=True,\n                  legend=dict(orientation='h', yanchor='bottom', y=-0.15, xanchor='center', x=0.5))\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\n\nHead-to-Head Matrix\nHow do the top 10 players fare against each other? Green indicates a winning record, red indicates a losing record.\n\nATP H2HWTA H2H\n\n\n\n\nATP Head-to-Head Matrix\ndef head_to_head_matrix(matches_df, players_df):\n    player_ids = players_df['player_id'].tolist()\n    player_names = players_df['full_name'].tolist()\n    h2h_matches = matches_df[(matches_df['winner_id'].isin(player_ids)) & (matches_df['loser_id'].isin(player_ids))]\n    \n    matrix_display = pd.DataFrame(index=player_names, columns=player_names)\n    matrix_numeric = pd.DataFrame(index=player_names, columns=player_names, dtype=float)\n    \n    for i, p1_id in enumerate(player_ids):\n        for j, p2_id in enumerate(player_ids):\n            if i == j:\n                matrix_display.iloc[i, j], matrix_numeric.iloc[i, j] = '-', np.nan\n            else:\n                wins = len(h2h_matches[(h2h_matches['winner_id'] == p1_id) & (h2h_matches['loser_id'] == p2_id)])\n                losses = len(h2h_matches[(h2h_matches['winner_id'] == p2_id) & (h2h_matches['loser_id'] == p1_id)])\n                total = wins + losses\n                matrix_display.iloc[i, j] = f\"{wins}-{losses}\" if total &gt; 0 else '0-0'\n                matrix_numeric.iloc[i, j] = (wins / total * 100) if total &gt; 0 else 50\n    \n    return matrix_display, matrix_numeric, len(h2h_matches)\n\natp_h2h_display, atp_h2h_numeric, atp_h2h_count = head_to_head_matrix(atp_matches, atp_players)\nshort_names = [n.split()[-1] for n in atp_h2h_numeric.index]\n\nfig = go.Figure(data=go.Heatmap(\n    z=atp_h2h_numeric.values, x=short_names, y=short_names,\n    colorscale='RdYlGn', zmin=0, zmax=100,\n    text=atp_h2h_display.values, texttemplate='%{text}',\n    hovertemplate='&lt;b&gt;%{y} vs %{x}&lt;/b&gt;&lt;br&gt;Record: %{text}&lt;br&gt;Win Rate: %{z:.0f}%&lt;extra&gt;&lt;/extra&gt;',\n    colorbar=dict(title='Win %', ticksuffix='%')\n))\n\nfig.update_layout(\n    title=f'ATP Head-to-Head ({atp_h2h_count} matches between Top 10)',\n    height=550, xaxis_title='Opponent', yaxis_title='Player',\n    yaxis=dict(autorange='reversed')\n)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\nWTA Head-to-Head Matrix\nwta_h2h_display, wta_h2h_numeric, wta_h2h_count = head_to_head_matrix(wta_matches, wta_players)\nshort_names_wta = [n.split()[-1] for n in wta_h2h_numeric.index]\n\nfig = go.Figure(data=go.Heatmap(\n    z=wta_h2h_numeric.values, x=short_names_wta, y=short_names_wta,\n    colorscale='RdYlGn', zmin=0, zmax=100,\n    text=wta_h2h_display.values, texttemplate='%{text}',\n    hovertemplate='&lt;b&gt;%{y} vs %{x}&lt;/b&gt;&lt;br&gt;Record: %{text}&lt;br&gt;Win Rate: %{z:.0f}%&lt;extra&gt;&lt;/extra&gt;',\n    colorbar=dict(title='Win %', ticksuffix='%')\n))\n\nfig.update_layout(\n    title=f'WTA Head-to-Head ({wta_h2h_count} matches between Top 10)',\n    height=550, xaxis_title='Opponent', yaxis_title='Player',\n    yaxis=dict(autorange='reversed')\n)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\n\nServe Analysis\nThe serve is crucial in tennis. Explore ace rates, double faults, and serve effectiveness.\n\nATP TourWTA Tour\n\n\n\n\nATP Serve Statistics\ndef calculate_serve_stats(matches_df, players_df):\n    results = []\n    for _, player in players_df.iterrows():\n        pid, name = player['player_id'], player['full_name']\n        wins = matches_df[matches_df['winner_id'] == pid][['w_ace', 'w_df', 'w_1stIn', 'w_svpt', 'w_1stWon', 'w_2ndWon']].copy()\n        wins.columns = ['aces', 'df', '1st_in', 'svpt', '1st_won', '2nd_won']\n        losses = matches_df[matches_df['loser_id'] == pid][['l_ace', 'l_df', 'l_1stIn', 'l_svpt', 'l_1stWon', 'l_2ndWon']].copy()\n        losses.columns = ['aces', 'df', '1st_in', 'svpt', '1st_won', '2nd_won']\n        all_m = pd.concat([wins, losses]).dropna()\n        if len(all_m) &gt; 0:\n            results.append({\n                'Player': name,\n                'Aces/Match': round(all_m['aces'].mean(), 1),\n                'DFs/Match': round(all_m['df'].mean(), 1),\n                '1st Serve %': round((all_m['1st_in'] / all_m['svpt']).mean() * 100, 1),\n                '1st Win %': round((all_m['1st_won'] / all_m['1st_in']).mean() * 100, 1),\n                '2nd Win %': round((all_m['2nd_won'] / (all_m['svpt'] - all_m['1st_in'])).mean() * 100, 1)\n            })\n    return pd.DataFrame(results)\n\natp_serve = calculate_serve_stats(atp_matches, atp_players)\n\nfig = make_subplots(rows=1, cols=2, subplot_titles=('Aces vs Double Faults', 'Serve Win Percentages'),\n                    horizontal_spacing=0.15)\n\nfig.add_trace(go.Scatter(\n    x=atp_serve['Aces/Match'], y=atp_serve['DFs/Match'],\n    mode='markers+text', text=atp_serve['Player'].str.split().str[-1],\n    textposition='top center', marker=dict(size=15, color='#1f77b4'),\n    hovertemplate='%{text}&lt;br&gt;Aces: %{x}&lt;br&gt;DFs: %{y}&lt;extra&gt;&lt;/extra&gt;'\n), row=1, col=1)\n\nfig.add_trace(go.Bar(\n    x=atp_serve['Player'].str.split().str[-1], y=atp_serve['1st Win %'],\n    name='1st Serve Win %', marker_color='#2ecc71'\n), row=1, col=2)\n\nfig.add_trace(go.Bar(\n    x=atp_serve['Player'].str.split().str[-1], y=atp_serve['2nd Win %'],\n    name='2nd Serve Win %', marker_color='#e74c3c'\n), row=1, col=2)\n\nfig.update_layout(height=450, showlegend=True, legend=dict(orientation='h', y=-0.15),\n                  title_text='ATP Serve Analysis')\nfig.update_xaxes(title_text='Aces per Match', row=1, col=1)\nfig.update_yaxes(title_text='Double Faults per Match', row=1, col=1)\nfig.update_xaxes(tickangle=45, row=1, col=2)\nfig.update_yaxes(title_text='Win %', row=1, col=2)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\nWTA Serve Statistics\nwta_serve = calculate_serve_stats(wta_matches, wta_players)\n\nfig = make_subplots(rows=1, cols=2, subplot_titles=('Aces vs Double Faults', 'Serve Win Percentages'),\n                    horizontal_spacing=0.15)\n\nfig.add_trace(go.Scatter(\n    x=wta_serve['Aces/Match'], y=wta_serve['DFs/Match'],\n    mode='markers+text', text=wta_serve['Player'].str.split().str[-1],\n    textposition='top center', marker=dict(size=15, color='#e377c2'),\n    hovertemplate='%{text}&lt;br&gt;Aces: %{x}&lt;br&gt;DFs: %{y}&lt;extra&gt;&lt;/extra&gt;'\n), row=1, col=1)\n\nfig.add_trace(go.Bar(\n    x=wta_serve['Player'].str.split().str[-1], y=wta_serve['1st Win %'],\n    name='1st Serve Win %', marker_color='#2ecc71'\n), row=1, col=2)\n\nfig.add_trace(go.Bar(\n    x=wta_serve['Player'].str.split().str[-1], y=wta_serve['2nd Win %'],\n    name='2nd Serve Win %', marker_color='#e74c3c'\n), row=1, col=2)\n\nfig.update_layout(height=450, showlegend=True, legend=dict(orientation='h', y=-0.15),\n                  title_text='WTA Serve Analysis')\nfig.update_xaxes(title_text='Aces per Match', row=1, col=1)\nfig.update_yaxes(title_text='Double Faults per Match', row=1, col=1)\nfig.update_xaxes(tickangle=45, row=1, col=2)\nfig.update_yaxes(title_text='Win %', row=1, col=2)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\n\nYearly Performance\nTrack player performance year over year with interactive range selection.\n\nATP Yearly WinsWTA Yearly Wins\n\n\n\n\nATP Yearly Performance\ndef yearly_wins(matches_df, players_df, start_year=2018):\n    matches_df = matches_df[matches_df['tourney_date'].dt.year &gt;= start_year].copy()\n    matches_df['year'] = matches_df['tourney_date'].dt.year\n    results = []\n    for _, player in players_df.iterrows():\n        pid, name = player['player_id'], player['full_name']\n        for year in range(start_year, 2025):\n            year_matches = matches_df[matches_df['year'] == year]\n            wins = len(year_matches[year_matches['winner_id'] == pid])\n            losses = len(year_matches[year_matches['loser_id'] == pid])\n            total = wins + losses\n            results.append({'Player': name, 'Year': year, 'Wins': wins, 'Losses': losses,\n                          'Win %': round(wins / total * 100, 1) if total &gt; 0 else 0})\n    return pd.DataFrame(results)\n\natp_yearly = yearly_wins(atp_matches, atp_players)\n\nfig = px.line(atp_yearly, x='Year', y='Wins', color='Player', markers=True,\n              hover_data={'Win %': True, 'Losses': True},\n              title='ATP Yearly Match Wins (2018-2024)')\n\nfig.update_layout(\n    height=500,\n    legend=dict(orientation='h', yanchor='bottom', y=-0.3, xanchor='center', x=0.5),\n    xaxis=dict(rangeslider=dict(visible=True, thickness=0.05), tickmode='linear', dtick=1)\n)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\nWTA Yearly Performance\nwta_yearly = yearly_wins(wta_matches, wta_players)\n\nfig = px.line(wta_yearly, x='Year', y='Wins', color='Player', markers=True,\n              hover_data={'Win %': True, 'Losses': True},\n              title='WTA Yearly Match Wins (2018-2024)')\n\nfig.update_layout(\n    height=500,\n    legend=dict(orientation='h', yanchor='bottom', y=-0.3, xanchor='center', x=0.5),\n    xaxis=dict(rangeslider=dict(visible=True, thickness=0.05), tickmode='linear', dtick=1)\n)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\n\nRankings Race Animation\nWatch how rankings have evolved from 2020 to 2024. Press Play to animate!\n\nATP TourWTA Tour\n\n\n\n\nATP Animated Rankings Race\natp_rankings['year'] = atp_rankings['date'].dt.year\natp_yearly_rank = atp_rankings[atp_rankings['year'] &gt;= 2020].groupby(['full_name', 'year']).agg(\n    best_rank=('rank', 'min')).reset_index()\n\nfig = px.bar(\n    atp_yearly_rank.sort_values(['year', 'best_rank']),\n    x='best_rank', y='full_name', color='full_name',\n    animation_frame='year', orientation='h', range_x=[0, 50],\n    title='ATP Best Ranking by Year (2020-2024)',\n    labels={'best_rank': 'Best Ranking', 'full_name': 'Player'},\n    color_discrete_sequence=px.colors.qualitative.Set2\n)\n\nfig.update_layout(\n    height=500, showlegend=False,\n    yaxis={'categoryorder': 'total ascending'},\n    xaxis={'autorange': 'reversed'}\n)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\nWTA Animated Rankings Race\nwta_rankings['year'] = wta_rankings['date'].dt.year\nwta_yearly_rank = wta_rankings[wta_rankings['year'] &gt;= 2020].groupby(['full_name', 'year']).agg(\n    best_rank=('rank', 'min')).reset_index()\n\nfig = px.bar(\n    wta_yearly_rank.sort_values(['year', 'best_rank']),\n    x='best_rank', y='full_name', color='full_name',\n    animation_frame='year', orientation='h', range_x=[0, 50],\n    title='WTA Best Ranking by Year (2020-2024)',\n    labels={'best_rank': 'Best Ranking', 'full_name': 'Player'},\n    color_discrete_sequence=px.colors.qualitative.Pastel\n)\n\nfig.update_layout(\n    height=500, showlegend=False,\n    yaxis={'categoryorder': 'total ascending'},\n    xaxis={'autorange': 'reversed'}\n)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\n\nMatch Duration Analysis\nHow long do matches last? Explore the rhythm of tennisâ€”from quick demolitions to marathon battles.\n\nATP TourWTA Tour\n\n\n\n\nATP Match Duration Analysis\ndef analyze_duration(matches_df, players_df):\n    results = []\n    for _, player in players_df.iterrows():\n        pid, name = player['player_id'], player['full_name']\n        wins = matches_df[matches_df['winner_id'] == pid][['minutes', 'best_of']].copy()\n        wins['result'] = 'Win'\n        losses = matches_df[matches_df['loser_id'] == pid][['minutes', 'best_of']].copy()\n        losses['result'] = 'Loss'\n        all_m = pd.concat([wins, losses]).dropna()\n        all_m['Player'] = name\n        results.append(all_m)\n    return pd.concat(results, ignore_index=True) if results else pd.DataFrame()\n\natp_duration = analyze_duration(atp_matches, atp_players)\n\n# Stats by player\natp_stats = atp_duration.groupby('Player').agg(\n    avg_duration=('minutes', 'mean'),\n    max_duration=('minutes', 'max'),\n    matches=('minutes', 'count')\n).reset_index().round(1)\n\nfig = make_subplots(rows=1, cols=2, subplot_titles=('Match Duration Distribution', 'Average Duration by Player'),\n                    horizontal_spacing=0.12)\n\n# Histogram\nfig.add_trace(go.Histogram(x=atp_duration['minutes'], nbinsx=30, \n                           marker_color='#1f77b4', opacity=0.7,\n                           name='All Matches'), row=1, col=1)\n\n# Bar chart\nfig.add_trace(go.Bar(\n    x=atp_stats.sort_values('avg_duration')['Player'].str.split().str[-1],\n    y=atp_stats.sort_values('avg_duration')['avg_duration'],\n    marker_color='#1f77b4',\n    text=atp_stats.sort_values('avg_duration')['avg_duration'],\n    textposition='outside'\n), row=1, col=2)\n\nfig.update_layout(height=400, showlegend=False, title_text='ATP Match Duration')\nfig.update_xaxes(title_text='Minutes', row=1, col=1)\nfig.update_yaxes(title_text='Number of Matches', row=1, col=1)\nfig.update_xaxes(tickangle=45, row=1, col=2)\nfig.update_yaxes(title_text='Avg Minutes', row=1, col=2)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\nWTA Match Duration Analysis\nwta_duration = analyze_duration(wta_matches, wta_players)\n\nwta_stats = wta_duration.groupby('Player').agg(\n    avg_duration=('minutes', 'mean'),\n    max_duration=('minutes', 'max'),\n    matches=('minutes', 'count')\n).reset_index().round(1)\n\nfig = make_subplots(rows=1, cols=2, subplot_titles=('Match Duration Distribution', 'Average Duration by Player'),\n                    horizontal_spacing=0.12)\n\nfig.add_trace(go.Histogram(x=wta_duration['minutes'], nbinsx=30,\n                           marker_color='#e377c2', opacity=0.7,\n                           name='All Matches'), row=1, col=1)\n\nfig.add_trace(go.Bar(\n    x=wta_stats.sort_values('avg_duration')['Player'].str.split().str[-1],\n    y=wta_stats.sort_values('avg_duration')['avg_duration'],\n    marker_color='#e377c2',\n    text=wta_stats.sort_values('avg_duration')['avg_duration'],\n    textposition='outside'\n), row=1, col=2)\n\nfig.update_layout(height=400, showlegend=False, title_text='WTA Match Duration')\nfig.update_xaxes(title_text='Minutes', row=1, col=1)\nfig.update_yaxes(title_text='Number of Matches', row=1, col=1)\nfig.update_xaxes(tickangle=45, row=1, col=2)\nfig.update_yaxes(title_text='Avg Minutes', row=1, col=2)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\n\nMental Toughness: Break Points\nBreak points are where matches are won and lost. Saving break points shows mental fortitude; converting them shows killer instinct.\n\nATP TourWTA Tour\n\n\n\n\nATP Break Point Analysis\ndef calculate_bp_stats(matches_df, players_df):\n    results = []\n    for _, player in players_df.iterrows():\n        pid, name = player['player_id'], player['full_name']\n        \n        wins = matches_df[matches_df['winner_id'] == pid]\n        losses = matches_df[matches_df['loser_id'] == pid]\n        \n        # Break points SAVED (on serve)\n        bp_faced_w = wins['w_bpFaced'].sum()\n        bp_saved_w = wins['w_bpSaved'].sum()\n        bp_faced_l = losses['l_bpFaced'].sum()\n        bp_saved_l = losses['l_bpSaved'].sum()\n        total_faced = bp_faced_w + bp_faced_l\n        total_saved = bp_saved_w + bp_saved_l\n        \n        # Break points CONVERTED (on return)\n        bp_opp_faced_w = wins['l_bpFaced'].sum()\n        bp_opp_saved_w = wins['l_bpSaved'].sum()\n        bp_opp_faced_l = losses['w_bpFaced'].sum()\n        bp_opp_saved_l = losses['w_bpSaved'].sum()\n        total_bp_chances = bp_opp_faced_w + bp_opp_faced_l\n        total_converted = (bp_opp_faced_w - bp_opp_saved_w) + (bp_opp_faced_l - bp_opp_saved_l)\n        \n        if total_faced &gt; 0 and total_bp_chances &gt; 0:\n            results.append({\n                'Player': name,\n                'BP Save %': round(total_saved / total_faced * 100, 1),\n                'BP Convert %': round(total_converted / total_bp_chances * 100, 1),\n                'BP Faced': int(total_faced),\n                'BP Chances': int(total_bp_chances)\n            })\n    return pd.DataFrame(results)\n\natp_bp = calculate_bp_stats(atp_matches, atp_players)\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n    x=atp_bp['BP Save %'], y=atp_bp['BP Convert %'],\n    mode='markers+text',\n    text=atp_bp['Player'].str.split().str[-1],\n    textposition='top center',\n    marker=dict(size=15, color='#1f77b4'),\n    hovertemplate='%{text}&lt;br&gt;Save: %{x}%&lt;br&gt;Convert: %{y}%&lt;extra&gt;&lt;/extra&gt;'\n))\n\n# Add quadrant lines\navg_save = atp_bp['BP Save %'].mean()\navg_conv = atp_bp['BP Convert %'].mean()\nfig.add_hline(y=avg_conv, line_dash=\"dash\", line_color=\"gray\", opacity=0.5)\nfig.add_vline(x=avg_save, line_dash=\"dash\", line_color=\"gray\", opacity=0.5)\n\nfig.update_layout(\n    height=500, title='ATP Break Point Performance',\n    xaxis_title='Break Point Save %', yaxis_title='Break Point Conversion %',\n    annotations=[\n        dict(x=0.95, y=0.95, xref='paper', yref='paper', text='Elite: Save & Convert', showarrow=False),\n        dict(x=0.05, y=0.05, xref='paper', yref='paper', text='Needs Work', showarrow=False)\n    ]\n)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\nWTA Break Point Analysis\nwta_bp = calculate_bp_stats(wta_matches, wta_players)\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n    x=wta_bp['BP Save %'], y=wta_bp['BP Convert %'],\n    mode='markers+text',\n    text=wta_bp['Player'].str.split().str[-1],\n    textposition='top center',\n    marker=dict(size=15, color='#e377c2'),\n    hovertemplate='%{text}&lt;br&gt;Save: %{x}%&lt;br&gt;Convert: %{y}%&lt;extra&gt;&lt;/extra&gt;'\n))\n\navg_save = wta_bp['BP Save %'].mean()\navg_conv = wta_bp['BP Convert %'].mean()\nfig.add_hline(y=avg_conv, line_dash=\"dash\", line_color=\"gray\", opacity=0.5)\nfig.add_vline(x=avg_save, line_dash=\"dash\", line_color=\"gray\", opacity=0.5)\n\nfig.update_layout(\n    height=500, title='WTA Break Point Performance',\n    xaxis_title='Break Point Save %', yaxis_title='Break Point Conversion %',\n    annotations=[\n        dict(x=0.95, y=0.95, xref='paper', yref='paper', text='Elite: Save & Convert', showarrow=False),\n        dict(x=0.05, y=0.05, xref='paper', yref='paper', text='Needs Work', showarrow=False)\n    ]\n)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\n\nTournament Level Performance\nNot all tournaments are equal. Grand Slams are the ultimate test (best of 5 for men), followed by Masters 1000 and other tiers.\n\nATP TourWTA Tour\n\n\n\n\nATP Tournament Level Analysis\nlevel_names = {\n    'G': 'Grand Slam', 'M': 'Masters 1000', 'A': 'ATP 500/250',\n    'F': 'Tour Finals', 'D': 'Davis Cup', 'C': 'Challengers'\n}\nlevel_order = ['Grand Slam', 'Tour Finals', 'Masters 1000', 'ATP 500/250', 'Davis Cup']\n\ndef tourney_level_stats(matches_df, players_df):\n    results = []\n    for _, player in players_df.iterrows():\n        pid, name = player['player_id'], player['full_name']\n        for level, level_name in level_names.items():\n            level_matches = matches_df[matches_df['tourney_level'] == level]\n            wins = len(level_matches[level_matches['winner_id'] == pid])\n            losses = len(level_matches[level_matches['loser_id'] == pid])\n            total = wins + losses\n            if total &gt;= 5:\n                results.append({\n                    'Player': name, 'Level': level_name,\n                    'Wins': wins, 'Losses': losses,\n                    'Win %': round(wins / total * 100, 1), 'Matches': total\n                })\n    return pd.DataFrame(results)\n\natp_level = tourney_level_stats(atp_matches, atp_players)\natp_pivot = atp_level.pivot(index='Player', columns='Level', values='Win %')\natp_pivot = atp_pivot[[c for c in level_order if c in atp_pivot.columns]]\n\nfig = go.Figure(data=go.Heatmap(\n    z=atp_pivot.values,\n    x=atp_pivot.columns,\n    y=atp_pivot.index,\n    colorscale='Blues',\n    zmin=50, zmax=95,\n    text=[[f'{v:.0f}%' if pd.notna(v) else '' for v in row] for row in atp_pivot.values],\n    texttemplate='%{text}',\n    textfont=dict(size=11),\n    hovertemplate='%{y}&lt;br&gt;%{x}: %{z:.1f}%&lt;extra&gt;&lt;/extra&gt;'\n))\n\nfig.update_layout(\n    height=450, title='ATP Win % by Tournament Level',\n    xaxis_title='Tournament Level', yaxis_title='Player'\n)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\nWTA Tournament Level Analysis\nwta_level_names = {\n    'G': 'Grand Slam', 'P': 'WTA 1000', 'PM': 'WTA 500',\n    'I': 'WTA 250', 'F': 'Tour Finals', 'D': 'BJK Cup'\n}\nwta_level_order = ['Grand Slam', 'Tour Finals', 'WTA 1000', 'WTA 500', 'WTA 250']\n\ndef wta_tourney_level_stats(matches_df, players_df):\n    results = []\n    for _, player in players_df.iterrows():\n        pid, name = player['player_id'], player['full_name']\n        for level, level_name in wta_level_names.items():\n            level_matches = matches_df[matches_df['tourney_level'] == level]\n            wins = len(level_matches[level_matches['winner_id'] == pid])\n            losses = len(level_matches[level_matches['loser_id'] == pid])\n            total = wins + losses\n            if total &gt;= 5:\n                results.append({\n                    'Player': name, 'Level': level_name,\n                    'Wins': wins, 'Losses': losses,\n                    'Win %': round(wins / total * 100, 1), 'Matches': total\n                })\n    return pd.DataFrame(results)\n\nwta_level = wta_tourney_level_stats(wta_matches, wta_players)\nwta_pivot = wta_level.pivot(index='Player', columns='Level', values='Win %')\nwta_pivot = wta_pivot[[c for c in wta_level_order if c in wta_pivot.columns]]\n\nfig = go.Figure(data=go.Heatmap(\n    z=wta_pivot.values,\n    x=wta_pivot.columns,\n    y=wta_pivot.index,\n    colorscale='RdPu',\n    zmin=50, zmax=95,\n    text=[[f'{v:.0f}%' if pd.notna(v) else '' for v in row] for row in wta_pivot.values],\n    texttemplate='%{text}',\n    textfont=dict(size=11),\n    hovertemplate='%{y}&lt;br&gt;%{x}: %{z:.1f}%&lt;extra&gt;&lt;/extra&gt;'\n))\n\nfig.update_layout(\n    height=450, title='WTA Win % by Tournament Level',\n    xaxis_title='Tournament Level', yaxis_title='Player'\n)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\n\nRound-by-Round Progression\nHow deep do players typically go in tournaments? This shows where players exit.\n\nATP TourWTA Tour\n\n\n\n\nATP Round Progression Analysis\nround_order = ['R128', 'R64', 'R32', 'R16', 'QF', 'SF', 'F', 'W']\n\ndef round_progression(matches_df, players_df):\n    results = []\n    for _, player in players_df.iterrows():\n        pid, name = player['player_id'], player['full_name']\n        losses = matches_df[matches_df['loser_id'] == pid].groupby('round').size()\n        final_wins = len(matches_df[(matches_df['winner_id'] == pid) & (matches_df['round'] == 'F')])\n        \n        row = {'Player': name}\n        for r in round_order[:-1]:\n            row[r] = losses.get(r, 0)\n        row['W'] = final_wins\n        results.append(row)\n    \n    df = pd.DataFrame(results)\n    df['Total'] = df[round_order].sum(axis=1)\n    return df\n\natp_rounds = round_progression(atp_matches, atp_players)\ncolors = ['#440154', '#482878', '#3e4989', '#31688e', '#26828e', '#1f9e89', '#35b779', '#6ece58']\n\nfig = go.Figure()\nfor i, r in enumerate(round_order):\n    fig.add_trace(go.Bar(\n        name=r if r != 'W' else 'Title',\n        x=atp_rounds['Player'].str.split().str[-1],\n        y=atp_rounds[r],\n        marker_color=colors[i]\n    ))\n\nfig.update_layout(\n    barmode='stack', height=450,\n    title='ATP Tournament Exit Distribution',\n    xaxis_title='Player', yaxis_title='Number of Tournaments',\n    legend_title='Exit Round'\n)\nfig.update_xaxes(tickangle=45)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\nWTA Round Progression Analysis\nwta_rounds = round_progression(wta_matches, wta_players)\ncolors_wta = ['#7b2d8e', '#8e3a9e', '#a147ae', '#b454be', '#c761ce', '#da6ede', '#ed7bee', '#ff88ff']\n\nfig = go.Figure()\nfor i, r in enumerate(round_order):\n    fig.add_trace(go.Bar(\n        name=r if r != 'W' else 'Title',\n        x=wta_rounds['Player'].str.split().str[-1],\n        y=wta_rounds[r],\n        marker_color=colors_wta[i]\n    ))\n\nfig.update_layout(\n    barmode='stack', height=450,\n    title='WTA Tournament Exit Distribution',\n    xaxis_title='Player', yaxis_title='Number of Tournaments',\n    legend_title='Exit Round'\n)\nfig.update_xaxes(tickangle=45)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\n\nAge & Performance Curves\nTennis players typically peak in their mid-20s. How do these top players perform at different ages?\n\nATP TourWTA Tour\n\n\n\n\nATP Age Performance Analysis\ndef age_performance(matches_df, players_df):\n    results = []\n    for _, player in players_df.iterrows():\n        pid, name = player['player_id'], player['full_name']\n        \n        wins = matches_df[matches_df['winner_id'] == pid][['tourney_date', 'winner_age']].copy()\n        wins.columns = ['date', 'age']\n        wins['result'] = 1\n        \n        losses = matches_df[matches_df['loser_id'] == pid][['tourney_date', 'loser_age']].copy()\n        losses.columns = ['date', 'age']\n        losses['result'] = 0\n        \n        all_m = pd.concat([wins, losses]).dropna()\n        all_m['age_bin'] = (all_m['age'] // 1).astype(int)\n        all_m['Player'] = name\n        results.append(all_m)\n    \n    return pd.concat(results, ignore_index=True) if results else pd.DataFrame()\n\natp_age = age_performance(atp_matches, atp_players)\natp_age_agg = atp_age.groupby(['Player', 'age_bin']).agg(\n    wins=('result', 'sum'), matches=('result', 'count')\n).reset_index()\natp_age_agg['win_pct'] = (atp_age_agg['wins'] / atp_age_agg['matches'] * 100).round(1)\natp_age_agg = atp_age_agg[atp_age_agg['matches'] &gt;= 10]\n\nfig = px.line(\n    atp_age_agg, x='age_bin', y='win_pct', color='Player',\n    title='ATP Win % by Age',\n    labels={'age_bin': 'Age', 'win_pct': 'Win %', 'Player': 'Player'},\n    markers=True\n)\n\nfig.update_layout(height=450, xaxis_title='Age', yaxis_title='Win %')\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\nWTA Age Performance Analysis\nwta_age = age_performance(wta_matches, wta_players)\nwta_age_agg = wta_age.groupby(['Player', 'age_bin']).agg(\n    wins=('result', 'sum'), matches=('result', 'count')\n).reset_index()\nwta_age_agg['win_pct'] = (wta_age_agg['wins'] / wta_age_agg['matches'] * 100).round(1)\nwta_age_agg = wta_age_agg[wta_age_agg['matches'] &gt;= 10]\n\nfig = px.line(\n    wta_age_agg, x='age_bin', y='win_pct', color='Player',\n    title='WTA Win % by Age',\n    labels={'age_bin': 'Age', 'win_pct': 'Win %', 'Player': 'Player'},\n    markers=True,\n    color_discrete_sequence=px.colors.qualitative.Pastel\n)\n\nfig.update_layout(height=450, xaxis_title='Age', yaxis_title='Win %')\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\n\nSeed vs Result: Upset Analysis\nDo players live up to their seeding? Who causes upsets, and who suffers them?\n\nATP TourWTA Tour\n\n\n\n\nATP Upset Analysis\ndef upset_analysis(matches_df, players_df):\n    results = []\n    for _, player in players_df.iterrows():\n        pid, name = player['player_id'], player['full_name']\n        wins = matches_df[matches_df['winner_id'] == pid].copy()\n        losses = matches_df[matches_df['loser_id'] == pid].copy()\n        \n        upsets_caused = 0\n        upsets_suffered = 0\n        \n        for _, match in wins.iterrows():\n            w_seed = match['winner_seed'] if pd.notna(match['winner_seed']) else 999\n            l_seed = match['loser_seed'] if pd.notna(match['loser_seed']) else 999\n            try:\n                w_seed, l_seed = int(w_seed), int(l_seed)\n            except:\n                continue\n            if w_seed &gt; l_seed:\n                upsets_caused += 1\n        \n        for _, match in losses.iterrows():\n            w_seed = match['winner_seed'] if pd.notna(match['winner_seed']) else 999\n            l_seed = match['loser_seed'] if pd.notna(match['loser_seed']) else 999\n            try:\n                w_seed, l_seed = int(w_seed), int(l_seed)\n            except:\n                continue\n            if w_seed &gt; l_seed:\n                upsets_suffered += 1\n        \n        total_matches = len(wins) + len(losses)\n        if total_matches &gt; 0:\n            results.append({\n                'Player': name,\n                'Upsets Caused': upsets_caused,\n                'Upsets Suffered': upsets_suffered,\n                'Net Upsets': upsets_caused - upsets_suffered\n            })\n    return pd.DataFrame(results)\n\natp_upsets = upset_analysis(atp_matches, atp_players)\n\nfig = go.Figure()\nfig.add_trace(go.Bar(\n    x=atp_upsets.sort_values('Net Upsets')['Player'].str.split().str[-1],\n    y=atp_upsets.sort_values('Net Upsets')['Upsets Caused'],\n    name='Upsets Caused', marker_color='#2ecc71'\n))\nfig.add_trace(go.Bar(\n    x=atp_upsets.sort_values('Net Upsets')['Player'].str.split().str[-1],\n    y=-atp_upsets.sort_values('Net Upsets')['Upsets Suffered'],\n    name='Upsets Suffered', marker_color='#e74c3c'\n))\n\nfig.update_layout(\n    barmode='relative', height=450,\n    title='ATP Upset Balance (Caused vs Suffered)',\n    xaxis_title='Player', yaxis_title='Number of Upsets'\n)\nfig.update_xaxes(tickangle=45)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\nWTA Upset Analysis\nwta_upsets = upset_analysis(wta_matches, wta_players)\n\nfig = go.Figure()\nfig.add_trace(go.Bar(\n    x=wta_upsets.sort_values('Net Upsets')['Player'].str.split().str[-1],\n    y=wta_upsets.sort_values('Net Upsets')['Upsets Caused'],\n    name='Upsets Caused', marker_color='#2ecc71'\n))\nfig.add_trace(go.Bar(\n    x=wta_upsets.sort_values('Net Upsets')['Player'].str.split().str[-1],\n    y=-wta_upsets.sort_values('Net Upsets')['Upsets Suffered'],\n    name='Upsets Suffered', marker_color='#e74c3c'\n))\n\nfig.update_layout(\n    barmode='relative', height=450,\n    title='WTA Upset Balance (Caused vs Suffered)',\n    xaxis_title='Player', yaxis_title='Number of Upsets'\n)\nfig.update_xaxes(tickangle=45)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\n\nScore Patterns & Match Dynamics\nHow do players win? Dominant straight-set victories or grinding 3-setters?\n\nATP TourWTA Tour\n\n\n\n\nATP Score Pattern Analysis\nimport re\n\ndef parse_score(score):\n    if pd.isna(score) or score in ['W/O', 'DEF', 'RET', 'ABN', 'walkover']:\n        return None, None, 0\n    \n    sets = str(score).split()\n    winner_sets = loser_sets = tiebreaks = 0\n    \n    for s in sets:\n        if '(' in s:\n            tiebreaks += 1\n        match = re.match(r'(\\d+)-(\\d+)', s)\n        if match:\n            g1, g2 = int(match.group(1)), int(match.group(2))\n            if g1 &gt; g2:\n                winner_sets += 1\n            else:\n                loser_sets += 1\n    \n    return winner_sets, loser_sets, tiebreaks\n\ndef analyze_scores(matches_df, players_df):\n    results = []\n    for _, player in players_df.iterrows():\n        pid, name = player['player_id'], player['full_name']\n        wins = matches_df[matches_df['winner_id'] == pid]\n        losses = matches_df[matches_df['loser_id'] == pid]\n        \n        straight_wins = deciding_wins = straight_losses = deciding_losses = 0\n        \n        for _, match in wins.iterrows():\n            ws, ls, _ = parse_score(match['score'])\n            if ws is not None:\n                if ls == 0:\n                    straight_wins += 1\n                else:\n                    deciding_wins += 1\n        \n        for _, match in losses.iterrows():\n            ws, ls, _ = parse_score(match['score'])\n            if ws is not None:\n                if ws - ls == 1:\n                    deciding_losses += 1\n                else:\n                    straight_losses += 1\n        \n        total_wins = straight_wins + deciding_wins\n        total_losses = straight_losses + deciding_losses\n        \n        if total_wins &gt; 0 and total_losses &gt; 0:\n            results.append({\n                'Player': name,\n                'Straight Set Win %': round(straight_wins / total_wins * 100, 1),\n                'Deciding Set Win %': round(deciding_wins / total_wins * 100, 1),\n                'Straight Set Loss %': round(straight_losses / total_losses * 100, 1)\n            })\n    return pd.DataFrame(results)\n\natp_scores = analyze_scores(atp_matches, atp_players)\n\nfig = go.Figure()\nfig.add_trace(go.Bar(\n    x=atp_scores['Player'].str.split().str[-1],\n    y=atp_scores['Straight Set Win %'],\n    name='Straight Set Wins', marker_color='#2ecc71'\n))\nfig.add_trace(go.Bar(\n    x=atp_scores['Player'].str.split().str[-1],\n    y=atp_scores['Deciding Set Win %'],\n    name='Deciding Set Wins', marker_color='#3498db'\n))\n\nfig.update_layout(\n    barmode='stack', height=450,\n    title='ATP Win Patterns: Straight Sets vs Deciding Sets',\n    xaxis_title='Player', yaxis_title='% of Wins'\n)\nfig.update_xaxes(tickangle=45)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\nWTA Score Pattern Analysis\nwta_scores = analyze_scores(wta_matches, wta_players)\n\nfig = go.Figure()\nfig.add_trace(go.Bar(\n    x=wta_scores['Player'].str.split().str[-1],\n    y=wta_scores['Straight Set Win %'],\n    name='Straight Set Wins', marker_color='#2ecc71'\n))\nfig.add_trace(go.Bar(\n    x=wta_scores['Player'].str.split().str[-1],\n    y=wta_scores['Deciding Set Win %'],\n    name='Deciding Set Wins', marker_color='#9b59b6'\n))\n\nfig.update_layout(\n    barmode='stack', height=450,\n    title='WTA Win Patterns: Straight Sets vs Deciding Sets',\n    xaxis_title='Player', yaxis_title='% of Wins'\n)\nfig.update_xaxes(tickangle=45)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\n\nReturn Game Analysis\nTennis is a game of serve and return. Great returners can neutralize big servers.\n\nATP TourWTA Tour\n\n\n\n\nATP Return Game Statistics\ndef calculate_return_stats(matches_df, players_df):\n    results = []\n    for _, player in players_df.iterrows():\n        pid, name = player['player_id'], player['full_name']\n        \n        wins = matches_df[matches_df['winner_id'] == pid][['l_svpt', 'l_1stIn', 'l_1stWon', 'l_2ndWon']].copy()\n        wins.columns = ['svpt', '1stIn', '1stWon', '2ndWon']\n        \n        losses = matches_df[matches_df['loser_id'] == pid][['w_svpt', 'w_1stIn', 'w_1stWon', 'w_2ndWon']].copy()\n        losses.columns = ['svpt', '1stIn', '1stWon', '2ndWon']\n        \n        all_m = pd.concat([wins, losses]).dropna()\n        \n        if len(all_m) &gt; 50:\n            total_1st_return_pts = all_m['1stIn'].sum()\n            pts_won_vs_1st = total_1st_return_pts - all_m['1stWon'].sum()\n            \n            total_2nd_return_pts = all_m['svpt'].sum() - all_m['1stIn'].sum()\n            pts_won_vs_2nd = total_2nd_return_pts - all_m['2ndWon'].sum()\n            \n            results.append({\n                'Player': name,\n                '1st Return %': round(pts_won_vs_1st / total_1st_return_pts * 100, 1),\n                '2nd Return %': round(pts_won_vs_2nd / total_2nd_return_pts * 100, 1)\n            })\n    return pd.DataFrame(results)\n\natp_return = calculate_return_stats(atp_matches, atp_players)\n\nfig = go.Figure()\nfig.add_trace(go.Bar(\n    x=atp_return['Player'].str.split().str[-1],\n    y=atp_return['1st Return %'],\n    name='vs 1st Serve', marker_color='#3498db'\n))\nfig.add_trace(go.Bar(\n    x=atp_return['Player'].str.split().str[-1],\n    y=atp_return['2nd Return %'],\n    name='vs 2nd Serve', marker_color='#e67e22'\n))\n\nfig.update_layout(\n    barmode='group', height=450,\n    title='ATP Return Points Won %',\n    xaxis_title='Player', yaxis_title='Points Won %'\n)\nfig.update_xaxes(tickangle=45)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\nWTA Return Game Statistics\nwta_return = calculate_return_stats(wta_matches, wta_players)\n\nfig = go.Figure()\nfig.add_trace(go.Bar(\n    x=wta_return['Player'].str.split().str[-1],\n    y=wta_return['1st Return %'],\n    name='vs 1st Serve', marker_color='#9b59b6'\n))\nfig.add_trace(go.Bar(\n    x=wta_return['Player'].str.split().str[-1],\n    y=wta_return['2nd Return %'],\n    name='vs 2nd Serve', marker_color='#e67e22'\n))\n\nfig.update_layout(\n    barmode='group', height=450,\n    title='WTA Return Points Won %',\n    xaxis_title='Player', yaxis_title='Points Won %'\n)\nfig.update_xaxes(tickangle=45)\nfig.show()\n\n\n                            \n                                            \n\n\n\n\n\n\n\nCarpet Court: A Surface Lost to Time\nIndoor carpet courts were once a staple of the tennis calendar but were phased out by 2009. Hereâ€™s a look at historical performance on this unique surface.\n\n\nCarpet Court Historical Analysis\n# Check if any carpet court matches exist in our data\ncarpet_matches_atp = atp_matches[atp_matches['surface'] == 'Carpet']\ncarpet_matches_wta = wta_matches[wta_matches['surface'] == 'Carpet']\n\nif len(carpet_matches_atp) &gt; 0 or len(carpet_matches_wta) &gt; 0:\n    print(f\"ATP Carpet matches found: {len(carpet_matches_atp)}\")\n    print(f\"WTA Carpet matches found: {len(carpet_matches_wta)}\")\nelse:\n    import plotly.graph_objects as go\n    \n    fig = go.Figure()\n    fig.add_annotation(\n        x=0.5, y=0.5, xref='paper', yref='paper',\n        text='Carpet courts were phased out before 2009.&lt;br&gt;No carpet matches in our 2020-2024 dataset.',\n        showarrow=False, font=dict(size=16)\n    )\n    fig.update_layout(\n        height=300, title='Carpet Court Era (Pre-2009)',\n        xaxis=dict(showgrid=False, showticklabels=False),\n        yaxis=dict(showgrid=False, showticklabels=False)\n    )\n    fig.show()\n\n\nATP Carpet matches found: 53\nWTA Carpet matches found: 16\n\n\n\n\nTeam Competition: Davis Cup & BJK Cup\nDavis Cup (ATP) and Billie Jean King Cup (WTA) are the premier team competitions in tennis.\n\nDavis Cup (ATP)BJK Cup (WTA)\n\n\n\n\nDavis Cup Analysis\ndavis_matches = atp_matches[atp_matches['tourney_level'] == 'D']\n\nif len(davis_matches) &gt; 10:\n    davis_results = []\n    for _, player in atp_players.iterrows():\n        pid, name = player['player_id'], player['full_name']\n        wins = len(davis_matches[davis_matches['winner_id'] == pid])\n        losses = len(davis_matches[davis_matches['loser_id'] == pid])\n        if wins + losses &gt; 0:\n            davis_results.append({\n                'Player': name,\n                'Wins': wins,\n                'Losses': losses,\n                'Win %': round(wins / (wins + losses) * 100, 1)\n            })\n    \n    davis_df = pd.DataFrame(davis_results)\n    \n    fig = go.Figure()\n    fig.add_trace(go.Bar(\n        x=davis_df.sort_values('Wins', ascending=False)['Player'].str.split().str[-1],\n        y=davis_df.sort_values('Wins', ascending=False)['Wins'],\n        name='Wins', marker_color='#1f77b4'\n    ))\n    fig.add_trace(go.Bar(\n        x=davis_df.sort_values('Wins', ascending=False)['Player'].str.split().str[-1],\n        y=davis_df.sort_values('Wins', ascending=False)['Losses'],\n        name='Losses', marker_color='#d62728'\n    ))\n    \n    fig.update_layout(\n        barmode='group', height=400,\n        title='Davis Cup Performance',\n        xaxis_title='Player', yaxis_title='Matches'\n    )\n    fig.update_xaxes(tickangle=45)\n    fig.show()\nelse:\n    print(\"Limited Davis Cup data available in dataset.\")\n\n\n                            \n                                            \n\n\n\n\n\n\nBJK Cup Analysis\nbjk_matches = wta_matches[wta_matches['tourney_level'] == 'D']\n\nif len(bjk_matches) &gt; 10:\n    bjk_results = []\n    for _, player in wta_players.iterrows():\n        pid, name = player['player_id'], player['full_name']\n        wins = len(bjk_matches[bjk_matches['winner_id'] == pid])\n        losses = len(bjk_matches[bjk_matches['loser_id'] == pid])\n        if wins + losses &gt; 0:\n            bjk_results.append({\n                'Player': name,\n                'Wins': wins,\n                'Losses': losses,\n                'Win %': round(wins / (wins + losses) * 100, 1)\n            })\n    \n    bjk_df = pd.DataFrame(bjk_results)\n    \n    fig = go.Figure()\n    fig.add_trace(go.Bar(\n        x=bjk_df.sort_values('Wins', ascending=False)['Player'].str.split().str[-1],\n        y=bjk_df.sort_values('Wins', ascending=False)['Wins'],\n        name='Wins', marker_color='#e377c2'\n    ))\n    fig.add_trace(go.Bar(\n        x=bjk_df.sort_values('Wins', ascending=False)['Player'].str.split().str[-1],\n        y=bjk_df.sort_values('Wins', ascending=False)['Losses'],\n        name='Losses', marker_color='#d62728'\n    ))\n    \n    fig.update_layout(\n        barmode='group', height=400,\n        title='Billie Jean King Cup Performance',\n        xaxis_title='Player', yaxis_title='Matches'\n    )\n    fig.update_xaxes(tickangle=45)\n    fig.show()\nelse:\n    print(\"Limited BJK Cup data available in dataset.\")\n\n\n                            \n                                            \n\n\n\n\n\n\n\nKey Insights\n\n\n\n\n\n\nSummary\n\n\n\nThis dashboard analyzed the Top 10 ATP and WTA players using match data from 2020-2024. Key findings:\n\nSurface specialists exist on both tours - some players dominate on clay, others on hard courts\nServe statistics show clear differences between tours, with ATP players generating more aces\nBreak point conversion separates the elite from the rest\nAge curves show players peaking at different ages based on playing style\nTournament level performance reveals who performs best under pressure at Grand Slams\n\nUse the ATP/WTA tabs to explore each tourâ€™s unique characteristics!"
  },
  {
    "objectID": "posts/cats-series/cats.html",
    "href": "posts/cats-series/cats.html",
    "title": "A series of Cats",
    "section": "",
    "text": "By Stable Diffusion\n\nYum\n\n\n\nFun\n\n\n\nWho said cats canâ€™t play tennis?\n\n\n\n\n\nWe love using our paws"
  },
  {
    "objectID": "CLAUDE.html",
    "href": "CLAUDE.html",
    "title": "CLAUDE.md",
    "section": "",
    "text": "This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n\n\nThis is a Quarto static website. Key commands:\n\nquarto preview - Start local development server with hot reload\nquarto render - Build full site to _site/ directory\nquarto render [file.qmd] - Render a single file\n\n\n\n\nFramework: Quarto 1.7.33 static site generator\nMain Pages: - index.qmd - Landing page with hero section - about.qmd - About page using Jolla template - blog.qmd - Blog listing page (grid layout) - resume.qmd - CV with HTML + PDF output\nBlog Posts: Located in posts/ directory. Each post is either a .qmd file or Jupyter notebook (.ipynb). Post-level config in posts/_metadata.yml sets freeze: true (caches computational output) and enables title block banners.\nOutput: Built site goes to _site/ (gitignored except for committed files)\n\n\n\n\n_quarto.yml - Site config: navbar, footer, dual themes (cosmo light/darkly dark)\nstyles.css - Custom CSS for hero sections, cards, animations, dark mode overrides\ncv.css - Resume-specific styling\n\n\n\n\n\nUses AOS.js for scroll animations\nCustom fonts: Space Grotesk (headings), Inter (body)\nResponsive design with Bootstrap grid from Quarto\nTheme toggle between light/dark modes\n\n\n\n\n\nMain branch: main\nDeployment branch: gh-pages (GitHub Pages)"
  },
  {
    "objectID": "CLAUDE.html#build-commands",
    "href": "CLAUDE.html#build-commands",
    "title": "CLAUDE.md",
    "section": "",
    "text": "This is a Quarto static website. Key commands:\n\nquarto preview - Start local development server with hot reload\nquarto render - Build full site to _site/ directory\nquarto render [file.qmd] - Render a single file"
  },
  {
    "objectID": "CLAUDE.html#project-structure",
    "href": "CLAUDE.html#project-structure",
    "title": "CLAUDE.md",
    "section": "",
    "text": "Framework: Quarto 1.7.33 static site generator\nMain Pages: - index.qmd - Landing page with hero section - about.qmd - About page using Jolla template - blog.qmd - Blog listing page (grid layout) - resume.qmd - CV with HTML + PDF output\nBlog Posts: Located in posts/ directory. Each post is either a .qmd file or Jupyter notebook (.ipynb). Post-level config in posts/_metadata.yml sets freeze: true (caches computational output) and enables title block banners.\nOutput: Built site goes to _site/ (gitignored except for committed files)"
  },
  {
    "objectID": "CLAUDE.html#configuration",
    "href": "CLAUDE.html#configuration",
    "title": "CLAUDE.md",
    "section": "",
    "text": "_quarto.yml - Site config: navbar, footer, dual themes (cosmo light/darkly dark)\nstyles.css - Custom CSS for hero sections, cards, animations, dark mode overrides\ncv.css - Resume-specific styling"
  },
  {
    "objectID": "CLAUDE.html#styling-notes",
    "href": "CLAUDE.html#styling-notes",
    "title": "CLAUDE.md",
    "section": "",
    "text": "Uses AOS.js for scroll animations\nCustom fonts: Space Grotesk (headings), Inter (body)\nResponsive design with Bootstrap grid from Quarto\nTheme toggle between light/dark modes"
  },
  {
    "objectID": "CLAUDE.html#deployment",
    "href": "CLAUDE.html#deployment",
    "title": "CLAUDE.md",
    "section": "",
    "text": "Main branch: main\nDeployment branch: gh-pages (GitHub Pages)"
  },
  {
    "objectID": "data/scrape_tennis.html",
    "href": "data/scrape_tennis.html",
    "title": "Tennis Abstract Web Scraper",
    "section": "",
    "text": "This notebook allows you to scrape recent tennis match data from Tennis Abstract for Top 25 ATP and WTA players.\nData Source: Tennis Abstract\nBase Data: Jeff Sackmannâ€™s tennis_atp/tennis_wta repos"
  },
  {
    "objectID": "data/scrape_tennis.html#setup-configuration",
    "href": "data/scrape_tennis.html#setup-configuration",
    "title": "Tennis Abstract Web Scraper",
    "section": "1. Setup & Configuration",
    "text": "1. Setup & Configuration\n\n# Configuration Options\n# =====================\n\n# Which tour to scrape: \"atp\", \"wta\", or \"both\"\nTOUR = \"both\"\n\n# Minimum year to scrape (matches before this year are skipped)\nMIN_YEAR = 2025\n\n# Maximum number of players to scrape per tour (None = all 25)\n# Use a small number (e.g., 3) for testing\nMAX_PLAYERS = None\n\n# Whether to merge scraped data with existing data\nMERGE_WITH_EXISTING = True\n\n# Rate limiting (seconds between requests)\nRATE_LIMIT_SECONDS = 2.0\n\n\n# Install dependencies if needed\nimport subprocess\nimport sys\n\ndef install_if_missing(package, import_name=None):\n    import_name = import_name or package\n    try:\n        __import__(import_name)\n        print(f\"âœ“ {package} already installed\")\n    except ImportError:\n        print(f\"Installing {package}...\")\n        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", package, \"-q\"])\n        print(f\"âœ“ {package} installed\")\n\ninstall_if_missing(\"playwright\")\ninstall_if_missing(\"pandas\")\n\n\n# Install Playwright browser (run once)\nimport os\nif not os.path.exists(os.path.expanduser(\"~/.cache/ms-playwright/chromium_headless_shell-1208\")):\n    print(\"Installing Chromium browser for Playwright...\")\n    !playwright install chromium\nelse:\n    print(\"âœ“ Chromium browser already installed\")\n\n\n# Imports\nimport csv\nimport re\nimport time\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom pathlib import Path\nfrom IPython.display import display, HTML, clear_output\n\nimport pandas as pd\nfrom playwright.sync_api import sync_playwright, TimeoutError as PlaywrightTimeout\n\nprint(\"âœ“ All imports successful\")"
  },
  {
    "objectID": "data/scrape_tennis.html#player-lists",
    "href": "data/scrape_tennis.html#player-lists",
    "title": "Tennis Abstract Web Scraper",
    "section": "2. Player Lists",
    "text": "2. Player Lists\nTop 25 players for each tour with their Tennis Abstract URL names.\n\n# Top 25 ATP Players (player_id, url_name, full_name)\nATP_TOP_25 = [\n    (206173, \"JannikSinner\", \"Jannik Sinner\"),\n    (100644, \"AlexanderZverev\", \"Alexander Zverev\"),\n    (207989, \"CarlosAlcaraz\", \"Carlos Alcaraz\"),\n    (126203, \"TaylorFritz\", \"Taylor Fritz\"),\n    (106421, \"DaniilMedvedev\", \"Daniil Medvedev\"),\n    (134770, \"AlexDeMinaur\", \"Alex de Minaur\"),\n    (104925, \"NovakDjokovic\", \"Novak Djokovic\"),\n    (126094, \"CasperRuud\", \"Casper Ruud\"),\n    (200282, \"AndreyRublev\", \"Andrey Rublev\"),\n    (105777, \"GrigorDimitrov\", \"Grigor Dimitrov\"),\n    (126774, \"TommyPaul\", \"Tommy Paul\"),\n    (126205, \"FrancesTiafoe\", \"Frances Tiafoe\"),\n    (208029, \"HolgerRune\", \"Holger Rune\"),\n    (200005, \"LorenzoMusetti\", \"Lorenzo Musetti\"),\n    (207733, \"UgoHumbert\", \"Ugo Humbert\"),\n    (128034, \"JackDraper\", \"Jack Draper\"),\n    (207518, \"ArthurFils\", \"Arthur Fils\"),\n    (126207, \"SebastianKorda\", \"Sebastian Korda\"),\n    (111575, \"KarenKhachanov\", \"Karen Khachanov\"),\n    (209950, \"AlexMichelsen\", \"Alex Michelsen\"),\n    (210097, \"GiovanniMpetshiPerricard\", \"Giovanni Mpetshi Perricard\"),\n    (200624, \"AdrianMannarino\", \"Adrian Mannarino\"),\n    (126214, \"BenShelton\", \"Ben Shelton\"),\n    (200615, \"FelixAugerAliassime\", \"Felix Auger-Aliassime\"),\n    (207830, \"TaroDaniel\", \"Taro Daniel\"),\n]\n\n# Top 25 WTA Players (player_id, url_name, full_name)\nWTA_TOP_25 = [\n    (214544, \"ArynaSabalenka\", \"Aryna Sabalenka\"),\n    (216347, \"IgaSwiatek\", \"Iga Swiatek\"),\n    (221103, \"CocoGauff\", \"Coco Gauff\"),\n    (211148, \"JasminePaolini\", \"Jasmine Paolini\"),\n    (221012, \"QinwenZheng\", \"Qinwen Zheng\"),\n    (214981, \"JessicaPegula\", \"Jessica Pegula\"),\n    (202468, \"ElenaRybakina\", \"Elena Rybakina\"),\n    (215613, \"EmmaNavarro\", \"Emma Navarro\"),\n    (214082, \"DariaKasatkina\", \"Daria Kasatkina\"),\n    (206252, \"BeatrizHaddadMaia\", \"Beatriz Haddad Maia\"),\n    (203389, \"DanielleCollins\", \"Danielle Collins\"),\n    (211651, \"MirraAndreeva\", \"Mirra Andreeva\"),\n    (223670, \"DianaShnaider\", \"Diana Shnaider\"),\n    (214939, \"AnnaKalinskaya\", \"Anna Kalinskaya\"),\n    (211533, \"DonnaVekic\", \"Donna Vekic\"),\n    (259799, \"MadisonKeys\", \"Madison Keys\"),\n    (206242, \"PaulaBadosa\", \"Paula Badosa\"),\n    (216146, \"LinaTsurenko\", \"Lina Tsurenko\"),\n    (202499, \"LindaNoskova\", \"Linda Noskova\"),\n    (201458, \"MarieBouzkova\", \"Marie Bouzkova\"),\n    (201619, \"KarolinaPliskova\", \"Karolina Pliskova\"),\n    (214096, \"AnastasiaPavlyuchenkova\", \"Anastasia Pavlyuchenkova\"),\n    (202494, \"ElinaSvitolina\", \"Elina Svitolina\"),\n    (211107, \"VeronikaKudermetova\", \"Veronika Kudermetova\"),\n    (211684, \"LeylaFernandez\", \"Leyla Fernandez\"),\n]\n\nprint(f\"ATP Players: {len(ATP_TOP_25)}\")\nprint(f\"WTA Players: {len(WTA_TOP_25)}\")"
  },
  {
    "objectID": "data/scrape_tennis.html#scraper-functions",
    "href": "data/scrape_tennis.html#scraper-functions",
    "title": "Tennis Abstract Web Scraper",
    "section": "3. Scraper Functions",
    "text": "3. Scraper Functions\n\n# Data directory setup\nDATA_DIR = Path(\".\")\nOUTPUT_DIR = DATA_DIR / \"top25\"\nOUTPUT_DIR.mkdir(exist_ok=True)\n(OUTPUT_DIR / \"atp\").mkdir(exist_ok=True)\n(OUTPUT_DIR / \"wta\").mkdir(exist_ok=True)\n\ndef get_match_columns():\n    \"\"\"Return column names matching Sackmann's format.\"\"\"\n    return [\n        \"tourney_id\", \"tourney_name\", \"surface\", \"draw_size\", \"tourney_level\",\n        \"tourney_date\", \"match_num\", \"winner_id\", \"winner_seed\", \"winner_entry\",\n        \"winner_name\", \"winner_hand\", \"winner_ht\", \"winner_ioc\", \"winner_age\",\n        \"loser_id\", \"loser_seed\", \"loser_entry\", \"loser_name\", \"loser_hand\",\n        \"loser_ht\", \"loser_ioc\", \"loser_age\", \"score\", \"best_of\", \"round\",\n        \"minutes\", \"w_ace\", \"w_df\", \"w_svpt\", \"w_1stIn\", \"w_1stWon\", \"w_2ndWon\",\n        \"w_SvGms\", \"w_bpSaved\", \"w_bpFaced\", \"l_ace\", \"l_df\", \"l_svpt\", \"l_1stIn\",\n        \"l_1stWon\", \"l_2ndWon\", \"l_SvGms\", \"l_bpSaved\", \"l_bpFaced\", \"winner_rank\",\n        \"winner_rank_points\", \"loser_rank\", \"loser_rank_points\"\n    ]\n\n\ndef parse_round(round_str):\n    \"\"\"Convert Tennis Abstract round format to Sackmann format.\"\"\"\n    round_map = {\n        \"F\": \"F\", \"SF\": \"SF\", \"QF\": \"QF\", \"R16\": \"R16\",\n        \"R32\": \"R32\", \"R64\": \"R64\", \"R128\": \"R128\", \"RR\": \"RR\", \"BR\": \"BR\",\n        \"1R\": \"R128\", \"2R\": \"R64\", \"3R\": \"R32\", \"4R\": \"R16\",\n    }\n    return round_map.get(round_str.strip(), round_str)\n\ndef parse_surface(surface_str):\n    \"\"\"Normalize surface names.\"\"\"\n    surface_str = surface_str.lower().strip()\n    if \"hard\" in surface_str: return \"Hard\"\n    elif \"clay\" in surface_str: return \"Clay\"\n    elif \"grass\" in surface_str: return \"Grass\"\n    elif \"carpet\" in surface_str: return \"Carpet\"\n    return surface_str.title()\n\ndef parse_date(date_str):\n    \"\"\"Parse date string and return (YYYYMMDD format, year).\"\"\"\n    formats = [\"%d-%b-%Y\", \"%Y-%m-%d\", \"%d %b %Y\", \"%b %d, %Y\", \"%Y/%m/%d\"]\n    for fmt in formats:\n        try:\n            dt = datetime.strptime(date_str.strip(), fmt)\n            return dt.strftime(\"%Y%m%d\"), dt.year\n        except ValueError:\n            continue\n    return \"\", 0\n\ndef parse_time_to_minutes(time_str):\n    \"\"\"Convert time string like '2:23' to minutes.\"\"\"\n    try:\n        parts = time_str.strip().split(':')\n        if len(parts) == 2:\n            return str(int(parts[0]) * 60 + int(parts[1]))\n    except (ValueError, IndexError):\n        pass\n    return \"\"\n\ndef parse_result_cell(result_text, player_name):\n    \"\"\"Parse result cell to extract winner/loser info.\"\"\"\n    if \" d. \" not in result_text:\n        return False, \"\", \"\", \"\", \"\"\n    \n    parts = result_text.split(\" d. \")\n    if len(parts) != 2:\n        return False, \"\", \"\", \"\", \"\"\n    \n    winner_part, loser_part = parts[0].strip(), parts[1].strip()\n    \n    def extract_seed(text):\n        match = re.search(r'\\((\\d+)\\)', text)\n        return match.group(1) if match else \"\"\n    \n    def extract_name(text):\n        text = re.sub(r'\\(\\d+\\)', '', text)\n        text = re.sub(r'\\[.*?\\]', '', text)\n        return text.strip()\n    \n    winner_seed = extract_seed(winner_part)\n    loser_seed = extract_seed(loser_part)\n    winner_name = extract_name(winner_part)\n    loser_name = extract_name(loser_part)\n    \n    player_last_name = player_name.split()[-1].lower()\n    winner_last_name = winner_name.split()[-1].lower() if winner_name else \"\"\n    player_won = player_last_name == winner_last_name\n    \n    return player_won, winner_name, loser_name, winner_seed, loser_seed\n\ndef parse_bp_saved(bp_text):\n    \"\"\"Parse break points saved like '5/8' into (saved, faced).\"\"\"\n    try:\n        if '/' in bp_text:\n            parts = bp_text.split('/')\n            return parts[0].strip(), parts[1].strip()\n    except (ValueError, IndexError):\n        pass\n    return \"\", \"\"\n\nprint(\"âœ“ Parser functions defined\")\n\n\ndef load_player_lookup(tour):\n    \"\"\"Load player info for ID lookup.\"\"\"\n    players = {}\n    player_file = DATA_DIR / f\"tennis_{tour}\" / f\"{tour}_players.csv\"\n    \n    if not player_file.exists():\n        return players\n    \n    with open(player_file, 'r') as f:\n        reader = csv.DictReader(f)\n        for row in reader:\n            name = f\"{row.get('name_first', '')} {row.get('name_last', '')}\".lower().strip()\n            players[name] = row\n            players[row.get('name_last', '').lower()] = row\n    \n    return players\n\nprint(\"âœ“ Player lookup function defined\")\n\n\ndef scrape_player_matches(page, player_id, url_name, full_name, tour, player_lookup, min_year):\n    \"\"\"Scrape recent matches for a single player.\"\"\"\n    matches = []\n    prefix = \"w\" if tour == \"wta\" else \"\"\n    url = f\"https://www.tennisabstract.com/cgi-bin/{prefix}player.cgi?p={url_name}\"\n    \n    try:\n        page.goto(url, timeout=60000, wait_until=\"domcontentloaded\")\n        page.wait_for_timeout(3000)\n        \n        table = page.query_selector(\"#recent-results\")\n        if not table:\n            return matches, \"No table found\"\n        \n        rows = table.query_selector_all(\"tr\")\n        \n        for row in rows[1:]:\n            cells = row.query_selector_all(\"td\")\n            if len(cells) &lt; 8:\n                continue\n            \n            try:\n                cell_texts = [c.inner_text().strip() for c in cells]\n                date_text = cell_texts[0]\n                tourney_date, year = parse_date(date_text)\n                \n                if year &lt; min_year:\n                    continue\n                \n                match = {col: \"\" for col in get_match_columns()}\n                match[\"tourney_date\"] = tourney_date\n                match[\"tourney_name\"] = cell_texts[1]\n                match[\"surface\"] = parse_surface(cell_texts[2])\n                match[\"round\"] = parse_round(cell_texts[3])\n                \n                player_rank = cell_texts[4]\n                opponent_rank = cell_texts[5]\n                \n                result_text = cell_texts[6]\n                player_won, winner_name, loser_name, winner_seed, loser_seed = parse_result_cell(\n                    result_text, full_name\n                )\n                \n                match[\"score\"] = cell_texts[7]\n                \n                clean_name = re.sub(r'[^a-zA-Z0-9]', '', match[\"tourney_name\"])\n                match[\"tourney_id\"] = f\"{year}-{clean_name[:20]}\"\n                \n                if player_won:\n                    match[\"winner_id\"] = str(player_id)\n                    match[\"winner_name\"] = full_name\n                    match[\"winner_seed\"] = winner_seed\n                    match[\"winner_rank\"] = player_rank\n                    match[\"loser_name\"] = loser_name or winner_name\n                    match[\"loser_seed\"] = loser_seed\n                    match[\"loser_rank\"] = opponent_rank\n                else:\n                    match[\"loser_id\"] = str(player_id)\n                    match[\"loser_name\"] = full_name\n                    match[\"loser_seed\"] = loser_seed\n                    match[\"loser_rank\"] = player_rank\n                    match[\"winner_name\"] = winner_name or loser_name\n                    match[\"winner_seed\"] = winner_seed\n                    match[\"winner_rank\"] = opponent_rank\n                \n                # Lookup opponent ID\n                opponent_name = match[\"loser_name\"] if player_won else match[\"winner_name\"]\n                opponent_info = player_lookup.get(opponent_name.lower(), {})\n                if not opponent_info:\n                    opponent_last = opponent_name.split()[-1].lower() if opponent_name else \"\"\n                    opponent_info = player_lookup.get(opponent_last, {})\n                \n                if opponent_info:\n                    if player_won:\n                        match[\"loser_id\"] = opponent_info.get('player_id', '')\n                    else:\n                        match[\"winner_id\"] = opponent_info.get('player_id', '')\n                \n                # Parse time and BP stats\n                if len(cell_texts) &gt; 15:\n                    match[\"minutes\"] = parse_time_to_minutes(cell_texts[15])\n                    if len(cell_texts) &gt; 14:\n                        bp_saved, bp_faced = parse_bp_saved(cell_texts[14])\n                        if player_won:\n                            match[\"w_bpSaved\"] = bp_saved\n                            match[\"w_bpFaced\"] = bp_faced\n                        else:\n                            match[\"l_bpSaved\"] = bp_saved\n                            match[\"l_bpFaced\"] = bp_faced\n                \n                matches.append(match)\n            \n            except Exception as e:\n                continue\n        \n        return matches, None\n    \n    except PlaywrightTimeout:\n        return matches, \"Timeout\"\n    except Exception as e:\n        return matches, str(e)\n\nprint(\"âœ“ Scraper function defined\")\n\n\ndef deduplicate_matches(matches):\n    \"\"\"Remove duplicate matches.\"\"\"\n    seen = set()\n    unique = []\n    \n    for match in matches:\n        names = sorted([match.get('winner_name', ''), match.get('loser_name', '')])\n        key = (\n            match.get('tourney_date', ''),\n            match.get('tourney_name', ''),\n            match.get('round', ''),\n            names[0],\n            names[1],\n        )\n        \n        if key not in seen and any(key):\n            seen.add(key)\n            unique.append(match)\n    \n    return unique\n\ndef merge_with_existing(new_matches, existing_file):\n    \"\"\"Merge new matches with existing data.\"\"\"\n    if not existing_file.exists():\n        return new_matches\n    \n    existing = pd.read_csv(existing_file)\n    existing_records = existing.to_dict('records')\n    \n    existing_keys = set()\n    for match in existing_records:\n        names = sorted([str(match.get('winner_name', '')), str(match.get('loser_name', ''))])\n        key = (\n            str(match.get('tourney_date', '')),\n            str(match.get('tourney_name', '')),\n            str(match.get('round', '')),\n            names[0],\n            names[1],\n        )\n        existing_keys.add(key)\n    \n    truly_new = []\n    for match in new_matches:\n        names = sorted([str(match.get('winner_name', '')), str(match.get('loser_name', ''))])\n        key = (\n            str(match.get('tourney_date', '')),\n            str(match.get('tourney_name', '')),\n            str(match.get('round', '')),\n            names[0],\n            names[1],\n        )\n        if key not in existing_keys:\n            truly_new.append(match)\n    \n    all_matches = existing_records + truly_new\n    all_matches.sort(key=lambda x: str(x.get('tourney_date', '')))\n    \n    return all_matches, len(truly_new)\n\ndef save_matches(matches, output_file):\n    \"\"\"Save matches to CSV.\"\"\"\n    if not matches:\n        return\n    \n    columns = get_match_columns()\n    with open(output_file, 'w', newline='') as f:\n        writer = csv.DictWriter(f, fieldnames=columns)\n        writer.writeheader()\n        for match in matches:\n            row = {col: match.get(col, '') for col in columns}\n            writer.writerow(row)\n\nprint(\"âœ“ Utility functions defined\")"
  },
  {
    "objectID": "data/scrape_tennis.html#run-the-scraper",
    "href": "data/scrape_tennis.html#run-the-scraper",
    "title": "Tennis Abstract Web Scraper",
    "section": "4. Run the Scraper",
    "text": "4. Run the Scraper\nExecute this cell to start scraping based on your configuration.\n\ndef run_scraper(tour, min_year, max_players, merge_with_existing_flag, rate_limit):\n    \"\"\"Main scraper function with progress display.\"\"\"\n    \n    results = {\"atp\": [], \"wta\": []}\n    \n    tours_to_scrape = [\"atp\", \"wta\"] if tour == \"both\" else [tour]\n    \n    for current_tour in tours_to_scrape:\n        players = ATP_TOP_25 if current_tour == \"atp\" else WTA_TOP_25\n        players_to_scrape = players[:max_players] if max_players else players\n        player_lookup = load_player_lookup(current_tour)\n        \n        print(f\"\\n{'='*60}\")\n        print(f\"Scraping {current_tour.upper()} - {len(players_to_scrape)} players\")\n        print(f\"Looking for matches from {min_year} onwards\")\n        print(f\"{'='*60}\\n\")\n        \n        all_matches = []\n        \n        with sync_playwright() as p:\n            browser = p.chromium.launch(headless=True)\n            context = browser.new_context(\n                user_agent=\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\"\n            )\n            page = context.new_page()\n            \n            for i, (player_id, url_name, full_name) in enumerate(players_to_scrape):\n                print(f\"[{i+1}/{len(players_to_scrape)}] {full_name}...\", end=\" \")\n                \n                matches, error = scrape_player_matches(\n                    page, player_id, url_name, full_name,\n                    current_tour, player_lookup, min_year\n                )\n                \n                if error:\n                    print(f\"âš ï¸ {error}\")\n                else:\n                    print(f\"âœ“ {len(matches)} matches\")\n                \n                all_matches.extend(matches)\n                time.sleep(rate_limit)\n            \n            browser.close()\n        \n        # Deduplicate\n        all_matches = deduplicate_matches(all_matches)\n        print(f\"\\nâ†’ Total unique matches: {len(all_matches)}\")\n        \n        # Save scraped data\n        scraped_file = OUTPUT_DIR / current_tour / f\"{current_tour}_top25_matches_scraped.csv\"\n        save_matches(all_matches, scraped_file)\n        print(f\"â†’ Saved to: {scraped_file}\")\n        \n        # Merge with existing\n        if merge_with_existing_flag and all_matches:\n            existing_file = OUTPUT_DIR / current_tour / f\"{current_tour}_top25_matches.csv\"\n            if existing_file.exists():\n                merged, new_count = merge_with_existing(all_matches, existing_file)\n                save_matches(merged, existing_file)\n                print(f\"â†’ Merged {new_count} new matches into {existing_file}\")\n                print(f\"â†’ Total matches in merged file: {len(merged)}\")\n        \n        results[current_tour] = all_matches\n    \n    return results\n\n# Run the scraper\nscraped_data = run_scraper(\n    tour=TOUR,\n    min_year=MIN_YEAR,\n    max_players=MAX_PLAYERS,\n    merge_with_existing_flag=MERGE_WITH_EXISTING,\n    rate_limit=RATE_LIMIT_SECONDS\n)\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"âœ“ Scraping Complete!\")\nprint(\"=\"*60)"
  },
  {
    "objectID": "data/scrape_tennis.html#view-results",
    "href": "data/scrape_tennis.html#view-results",
    "title": "Tennis Abstract Web Scraper",
    "section": "5. View Results",
    "text": "5. View Results\n\n# Load and display scraped data\nfor tour in [\"atp\", \"wta\"]:\n    scraped_file = OUTPUT_DIR / tour / f\"{tour}_top25_matches_scraped.csv\"\n    if scraped_file.exists():\n        df = pd.read_csv(scraped_file)\n        print(f\"\\n{tour.upper()} Scraped Matches: {len(df)}\")\n        print(f\"Columns: {len(df.columns)}\")\n        \n        if len(df) &gt; 0:\n            display(df[[\"tourney_date\", \"tourney_name\", \"surface\", \"round\", \n                       \"winner_name\", \"loser_name\", \"score\"]].head(10))\n\n\n# Summary statistics\nfor tour in [\"atp\", \"wta\"]:\n    merged_file = OUTPUT_DIR / tour / f\"{tour}_top25_matches.csv\"\n    if merged_file.exists():\n        df = pd.read_csv(merged_file)\n        df['tourney_date'] = pd.to_datetime(df['tourney_date'], format='%Y%m%d', errors='coerce')\n        \n        print(f\"\\n{'='*40}\")\n        print(f\"{tour.upper()} Full Dataset Statistics\")\n        print(f\"{'='*40}\")\n        print(f\"Total matches: {len(df):,}\")\n        print(f\"Date range: {df['tourney_date'].min().date()} to {df['tourney_date'].max().date()}\")\n        print(f\"\\nMatches by year (recent):\")\n        print(df.groupby(df['tourney_date'].dt.year).size().tail(5))\n        print(f\"\\nTop tournaments:\")\n        print(df['tourney_name'].value_counts().head(10))"
  },
  {
    "objectID": "data/scrape_tennis.html#custom-single-player-scrape",
    "href": "data/scrape_tennis.html#custom-single-player-scrape",
    "title": "Tennis Abstract Web Scraper",
    "section": "6. Custom Single Player Scrape",
    "text": "6. Custom Single Player Scrape\nScrape a specific player by name.\n\ndef scrape_single_player(player_name, tour=\"atp\", min_year=2025):\n    \"\"\"Scrape matches for a single player by name.\"\"\"\n    players = ATP_TOP_25 if tour == \"atp\" else WTA_TOP_25\n    \n    # Find player\n    player = None\n    for p in players:\n        if player_name.lower() in p[2].lower():\n            player = p\n            break\n    \n    if not player:\n        print(f\"Player '{player_name}' not found in {tour.upper()} Top 25\")\n        return None\n    \n    player_id, url_name, full_name = player\n    player_lookup = load_player_lookup(tour)\n    \n    print(f\"Scraping {full_name}...\")\n    \n    with sync_playwright() as p:\n        browser = p.chromium.launch(headless=True)\n        context = browser.new_context(\n            user_agent=\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\"\n        )\n        page = context.new_page()\n        \n        matches, error = scrape_player_matches(\n            page, player_id, url_name, full_name,\n            tour, player_lookup, min_year\n        )\n        \n        browser.close()\n    \n    if error:\n        print(f\"Error: {error}\")\n        return None\n    \n    df = pd.DataFrame(matches)\n    print(f\"Found {len(df)} matches from {min_year}+\")\n    return df\n\n# Example: Scrape Sinner's recent matches\n# sinner_matches = scrape_single_player(\"Sinner\", tour=\"atp\", min_year=2025)\n# display(sinner_matches)\n\n\n# Uncomment and run to scrape a specific player:\n\n# sinner_matches = scrape_single_player(\"Sinner\", tour=\"atp\", min_year=2025)\n# if sinner_matches is not None:\n#     display(sinner_matches[[\"tourney_date\", \"tourney_name\", \"round\", \"winner_name\", \"loser_name\", \"score\"]])"
  },
  {
    "objectID": "resume.html",
    "href": "resume.html",
    "title": "Ali Zaidi",
    "section": "",
    "text": "Product Leader & Applied AI Engineer\nazaidi06@gmail.com | linkedin.com/in/azaidi06 | github.com/azaidi06"
  },
  {
    "objectID": "resume.html#work-experience",
    "href": "resume.html#work-experience",
    "title": "Ali Zaidi",
    "section": "Work Experience",
    "text": "Work Experience\n\nCofounder & Head of Data Science\nEagleSwing August 2025 â€“ Present\n\nEnd-to-End Product Architecture\n\n\n\nComputer Systems Engineer 2\nLawrence Berkeley National Laboratory June 2022 â€“ September 2025\n\nLLM Research & Optimization\n\n\n\nComputer Systems Engineer 1\nLawrence Berkeley National Laboratory June 2021 â€“ May 2022\n\nGenomic Deep Learning\nDistributed Training\n\n\n\nMachine Learning Intern\nLawrence Berkeley National Laboratory November 2020 â€“ May 2021\n\nProtein Folding Analysis\nCluster Management\n\n\n\nSenior Project Manager\nFuze November 2019 â€“ May 2021\n\nSenior manager handling major clients + mentoring junior staff\n\n\n\nProgram Manager\nPharmaceutics International Inc. March 2014 â€“ July 2016\n\nFDA drug submission + responses (2014-2016)\nInternal R&D manager (2014-2015)\nManaged client Softgel + Hard Shell R&D and manufacturing operations"
  },
  {
    "objectID": "resume.html#education",
    "href": "resume.html#education",
    "title": "Ali Zaidi",
    "section": "Education",
    "text": "Education\n\nBachelors of Science â€“ Finance\nUniversity of Maryland College Park May 2012\n\n\nPost Baccalaureate â€“ Pre-Medicine\nUniversity of Maryland College Park May 2013"
  },
  {
    "objectID": "resume.html#skills",
    "href": "resume.html#skills",
    "title": "Ali Zaidi",
    "section": "Skills",
    "text": "Skills\nData Science: Computer Vision, NLP, LLMs, Data Engineering\nSoftware: Python, PyTorch, FastAPI, Docker, Git/CI-CD\nCloud: AWS, HPC/SLURM, Scalable Inference Systems"
  },
  {
    "objectID": "resume.html#publications",
    "href": "resume.html#publications",
    "title": "Ali Zaidi",
    "section": "Publications",
    "text": "Publications\n\nZero-shot data citation function classification using Transformer-based large language models (Nov 2025)\nCases of Refractory Anemia with Ringed Sideroblasts Who Responded to Chloroquine (Aug 2014)"
  },
  {
    "objectID": "old_index.html",
    "href": "old_index.html",
    "title": "Ali Zaidi",
    "section": "",
    "text": "BringingData toLife\n    \n    \n      Applied Data Scientist \n      Software Engineer \n      Product Leader\n    \n  \n\n\n\n\n\nAbout Me\n\nBackground, skills, and expertise\n\n\n\n\n\n\n\nPersonal Blog\n\nThoughts, tutorials, and photos\n\n\n\n\n\n\n\nProfessional Resume\n\nExperience and qualifications\n\n\n\n\n\n\nAreas of Interest\n\nSoftware, Science, Healthcare"
  },
  {
    "objectID": "posts/tennis-analysis-CLAUDE.html",
    "href": "posts/tennis-analysis-CLAUDE.html",
    "title": "Tennis Analysis CLAUDE.md",
    "section": "",
    "text": "Project-specific instructions for tennis analysis notebooks and data.\n\n\nRaw Data: Jeff Sackmannâ€™s Tennis Abstract repositories (CC BY-NC-SA 4.0) - ATP: data/tennis_atp/ (git submodule) - WTA: data/tennis_wta/ (git submodule)\nExtracted Subsets: - data/top10/ - Top 10 players (Dec 30, 2024 rankings) - data/top25/ - Top 25 players\n\n\nEach tour directory (atp/, wta/) contains: - *_topN_players.csv - Player biographical data - *_topN_rankings.csv - Complete ranking history - *_topN_matches.csv - All matches involving these players\n\n\n\nPlayers: | Column | Description | |â€”â€”â€“|â€”â€”â€”â€”-| | player_id | Unique identifier (use for joins) | | name_first, name_last | Name components | | full_name | Created as name_first + ' ' + name_last | | hand | L/R | | dob | Date of birth (YYYYMMDD format) | | ioc | Country code | | height | In centimeters |\nMatches: | Column | Description | |â€”â€”â€“|â€”â€”â€”â€”-| | tourney_date | Tournament date (YYYYMMDD, parse to datetime) | | surface | Hard, Clay, Grass, Carpet | | tourney_level | G=Grand Slam, M=Masters, A=ATP 500/250, F=Finals, D=Davis/BJK Cup | | winner_id, loser_id | Player IDs | | score | Match score string | | minutes | Match duration |\nServe Statistics (prefixed w_ for winner, l_ for loser): | Column | Description | |â€”â€”â€“|â€”â€”â€”â€”-| | *_ace | Aces | | *_df | Double faults | | *_svpt | Total serve points | | *_1stIn | First serves in | | *_1stWon | Points won on first serve | | *_2ndWon | Points won on second serve | | *_bpSaved | Break points saved | | *_bpFaced | Break points faced |\n\n\n\n\n\n\nInteractive dashboard with Top 10 player analysis: - Player overview and win rates - Rankings history with range slider - Surface performance heatmaps - Head-to-head matrices - Serve analysis - Tournament level performance\n\n\n\nDeep dive into serve statistics with Top 25 players: - Tour averages comparison - Winner vs loser differentials - Ace production scatter plots - First serve accuracy vs effectiveness - Break point performance - Surface impact on serve stats\n\n\n\n\n\n\nDATA_PATH = '../../data/top25'  # or top10\natp_players = pd.read_csv(f'{DATA_PATH}/atp/atp_top25_players.csv')\natp_matches = pd.read_csv(f'{DATA_PATH}/atp/atp_top25_matches.csv')\nwta_players = pd.read_csv(f'{DATA_PATH}/wta/wta_top25_players.csv')\nwta_matches = pd.read_csv(f'{DATA_PATH}/wta/wta_top25_matches.csv')\n\n# Always create full_name\nfor df in [atp_players, wta_players]:\n    df['full_name'] = df['name_first'] + ' ' + df['name_last']\n\n# Parse dates\natp_matches['tourney_date'] = pd.to_datetime(atp_matches['tourney_date'].astype(str), format='%Y%m%d')\n\n\n\nserve_cols = ['w_ace', 'w_df', 'w_svpt', 'w_1stIn', 'w_1stWon', 'w_2ndWon', 'w_SvGms', 'w_bpSaved', 'w_bpFaced']\natp_serve_matches = atp_matches.dropna(subset=serve_cols)\n\n\n\ndef calculate_stats(matches_df, players_df):\n    results = []\n    for _, player in players_df.iterrows():\n        pid, name = player['player_id'], player['full_name']\n\n        # Get wins and losses separately\n        wins = matches_df[matches_df['winner_id'] == pid][['w_col1', 'w_col2']].copy()\n        wins.columns = ['col1', 'col2']  # Normalize column names\n        losses = matches_df[matches_df['loser_id'] == pid][['l_col1', 'l_col2']].copy()\n        losses.columns = ['col1', 'col2']\n\n        all_matches = pd.concat([wins, losses]).dropna()\n\n        if len(all_matches) &gt;= 20:  # Minimum match threshold\n            results.append({\n                'Player': name.split()[-1],  # Last name only for display\n                'Stat': calculate_something(all_matches)\n            })\n    return pd.DataFrame(results)\n\n\n\n# CSV row order may not equal ranking - add explicit rank if available\natp_players['rank'] = range(1, len(atp_players) + 1)\n\n\n\n\n\n\n\nATP: #1f77b4 (blue)\nWTA: #e377c2 (pink)\n\n\n\n\n::: {.panel-tabset}\n\n## ATP\n```python code here```\n\n## WTA\n```python code here```\n\n:::\n\n\n\ndef create_scatter_with_filters(df, color, x_col, y_col, x_label, y_label, div_id):\n    fig = go.Figure()\n    for i, row in df.iterrows():\n        fig.add_trace(go.Scatter(\n            x=[row[x_col]], y=[row[y_col]],\n            mode='markers+text',\n            text=[row['Player']], textposition='top center',\n            marker=dict(size=10, color=color),\n            name=row['Player']\n        ))\n    # Add reference lines at mean\n    fig.add_hline(y=df[y_col].mean(), line_dash='dash', line_color='gray', opacity=0.5)\n    fig.add_vline(x=df[x_col].mean(), line_dash='dash', line_color='gray', opacity=0.5)\n    return fig\n\n# Use with custom div_id for JavaScript targeting\nhtml = fig.to_html(full_html=False, include_plotlyjs=False, div_id='my-chart-id')\ndisplay(HTML(html))\n\n\n\nWhen multiple charts need synchronized player filtering, use: 1. Calculate all stats upfront in a single cell 2. Create canonical player list (intersection of all charts) 3. Add HTML/JS widget with display(HTML(widget_html)) 4. Use Plotly.restyle(el, {visible: visibility_array}) to sync charts\n\n\n\n\n\n\nExtracts top 10 player data. Modify ATP_TOP_10 and WTA_TOP_10 lists with player IDs.\n\n\n\nSame pattern for top 25 players.\nTo run:\ncd data\npython extract_top25.py\n\n\n\n\n# Render single notebook\nquarto render posts/serve-analysis/serve-analysis.ipynb --execute\n\n# Preview site\nquarto preview\n\n\n\n\nMissing serve data: Many older matches lack serve statistics. Filter with dropna(subset=serve_cols).\nPlayer ID mismatches: Always join on player_id, not name (names can have variants).\nDate parsing: Dates are stored as YYYYMMDD integers. Use format='%Y%m%d' with pd.to_datetime().\nJavaScript in f-strings: When embedding JS in Python f-strings, escape braces {{ and }}. For template literals with ${}, use string concatenation: '.' + tour + '-player' instead of template syntax.\nPlotly in Quarto: Use fig.to_html(full_html=False, include_plotlyjs=False, div_id='unique-id') for charts that need JavaScript interaction. Quarto includes Plotly globally."
  },
  {
    "objectID": "posts/tennis-analysis-CLAUDE.html#data-sources",
    "href": "posts/tennis-analysis-CLAUDE.html#data-sources",
    "title": "Tennis Analysis CLAUDE.md",
    "section": "",
    "text": "Raw Data: Jeff Sackmannâ€™s Tennis Abstract repositories (CC BY-NC-SA 4.0) - ATP: data/tennis_atp/ (git submodule) - WTA: data/tennis_wta/ (git submodule)\nExtracted Subsets: - data/top10/ - Top 10 players (Dec 30, 2024 rankings) - data/top25/ - Top 25 players\n\n\nEach tour directory (atp/, wta/) contains: - *_topN_players.csv - Player biographical data - *_topN_rankings.csv - Complete ranking history - *_topN_matches.csv - All matches involving these players\n\n\n\nPlayers: | Column | Description | |â€”â€”â€“|â€”â€”â€”â€”-| | player_id | Unique identifier (use for joins) | | name_first, name_last | Name components | | full_name | Created as name_first + ' ' + name_last | | hand | L/R | | dob | Date of birth (YYYYMMDD format) | | ioc | Country code | | height | In centimeters |\nMatches: | Column | Description | |â€”â€”â€“|â€”â€”â€”â€”-| | tourney_date | Tournament date (YYYYMMDD, parse to datetime) | | surface | Hard, Clay, Grass, Carpet | | tourney_level | G=Grand Slam, M=Masters, A=ATP 500/250, F=Finals, D=Davis/BJK Cup | | winner_id, loser_id | Player IDs | | score | Match score string | | minutes | Match duration |\nServe Statistics (prefixed w_ for winner, l_ for loser): | Column | Description | |â€”â€”â€“|â€”â€”â€”â€”-| | *_ace | Aces | | *_df | Double faults | | *_svpt | Total serve points | | *_1stIn | First serves in | | *_1stWon | Points won on first serve | | *_2ndWon | Points won on second serve | | *_bpSaved | Break points saved | | *_bpFaced | Break points faced |"
  },
  {
    "objectID": "posts/tennis-analysis-CLAUDE.html#notebooks",
    "href": "posts/tennis-analysis-CLAUDE.html#notebooks",
    "title": "Tennis Analysis CLAUDE.md",
    "section": "",
    "text": "Interactive dashboard with Top 10 player analysis: - Player overview and win rates - Rankings history with range slider - Surface performance heatmaps - Head-to-head matrices - Serve analysis - Tournament level performance\n\n\n\nDeep dive into serve statistics with Top 25 players: - Tour averages comparison - Winner vs loser differentials - Ace production scatter plots - First serve accuracy vs effectiveness - Break point performance - Surface impact on serve stats"
  },
  {
    "objectID": "posts/tennis-analysis-CLAUDE.html#code-patterns",
    "href": "posts/tennis-analysis-CLAUDE.html#code-patterns",
    "title": "Tennis Analysis CLAUDE.md",
    "section": "",
    "text": "DATA_PATH = '../../data/top25'  # or top10\natp_players = pd.read_csv(f'{DATA_PATH}/atp/atp_top25_players.csv')\natp_matches = pd.read_csv(f'{DATA_PATH}/atp/atp_top25_matches.csv')\nwta_players = pd.read_csv(f'{DATA_PATH}/wta/wta_top25_players.csv')\nwta_matches = pd.read_csv(f'{DATA_PATH}/wta/wta_top25_matches.csv')\n\n# Always create full_name\nfor df in [atp_players, wta_players]:\n    df['full_name'] = df['name_first'] + ' ' + df['name_last']\n\n# Parse dates\natp_matches['tourney_date'] = pd.to_datetime(atp_matches['tourney_date'].astype(str), format='%Y%m%d')\n\n\n\nserve_cols = ['w_ace', 'w_df', 'w_svpt', 'w_1stIn', 'w_1stWon', 'w_2ndWon', 'w_SvGms', 'w_bpSaved', 'w_bpFaced']\natp_serve_matches = atp_matches.dropna(subset=serve_cols)\n\n\n\ndef calculate_stats(matches_df, players_df):\n    results = []\n    for _, player in players_df.iterrows():\n        pid, name = player['player_id'], player['full_name']\n\n        # Get wins and losses separately\n        wins = matches_df[matches_df['winner_id'] == pid][['w_col1', 'w_col2']].copy()\n        wins.columns = ['col1', 'col2']  # Normalize column names\n        losses = matches_df[matches_df['loser_id'] == pid][['l_col1', 'l_col2']].copy()\n        losses.columns = ['col1', 'col2']\n\n        all_matches = pd.concat([wins, losses]).dropna()\n\n        if len(all_matches) &gt;= 20:  # Minimum match threshold\n            results.append({\n                'Player': name.split()[-1],  # Last name only for display\n                'Stat': calculate_something(all_matches)\n            })\n    return pd.DataFrame(results)\n\n\n\n# CSV row order may not equal ranking - add explicit rank if available\natp_players['rank'] = range(1, len(atp_players) + 1)"
  },
  {
    "objectID": "posts/tennis-analysis-CLAUDE.html#visualization-patterns",
    "href": "posts/tennis-analysis-CLAUDE.html#visualization-patterns",
    "title": "Tennis Analysis CLAUDE.md",
    "section": "",
    "text": "ATP: #1f77b4 (blue)\nWTA: #e377c2 (pink)\n\n\n\n\n::: {.panel-tabset}\n\n## ATP\n```python code here```\n\n## WTA\n```python code here```\n\n:::\n\n\n\ndef create_scatter_with_filters(df, color, x_col, y_col, x_label, y_label, div_id):\n    fig = go.Figure()\n    for i, row in df.iterrows():\n        fig.add_trace(go.Scatter(\n            x=[row[x_col]], y=[row[y_col]],\n            mode='markers+text',\n            text=[row['Player']], textposition='top center',\n            marker=dict(size=10, color=color),\n            name=row['Player']\n        ))\n    # Add reference lines at mean\n    fig.add_hline(y=df[y_col].mean(), line_dash='dash', line_color='gray', opacity=0.5)\n    fig.add_vline(x=df[x_col].mean(), line_dash='dash', line_color='gray', opacity=0.5)\n    return fig\n\n# Use with custom div_id for JavaScript targeting\nhtml = fig.to_html(full_html=False, include_plotlyjs=False, div_id='my-chart-id')\ndisplay(HTML(html))\n\n\n\nWhen multiple charts need synchronized player filtering, use: 1. Calculate all stats upfront in a single cell 2. Create canonical player list (intersection of all charts) 3. Add HTML/JS widget with display(HTML(widget_html)) 4. Use Plotly.restyle(el, {visible: visibility_array}) to sync charts"
  },
  {
    "objectID": "posts/tennis-analysis-CLAUDE.html#extract-scripts",
    "href": "posts/tennis-analysis-CLAUDE.html#extract-scripts",
    "title": "Tennis Analysis CLAUDE.md",
    "section": "",
    "text": "Extracts top 10 player data. Modify ATP_TOP_10 and WTA_TOP_10 lists with player IDs.\n\n\n\nSame pattern for top 25 players.\nTo run:\ncd data\npython extract_top25.py"
  },
  {
    "objectID": "posts/tennis-analysis-CLAUDE.html#testing",
    "href": "posts/tennis-analysis-CLAUDE.html#testing",
    "title": "Tennis Analysis CLAUDE.md",
    "section": "",
    "text": "# Render single notebook\nquarto render posts/serve-analysis/serve-analysis.ipynb --execute\n\n# Preview site\nquarto preview"
  },
  {
    "objectID": "posts/tennis-analysis-CLAUDE.html#common-issues",
    "href": "posts/tennis-analysis-CLAUDE.html#common-issues",
    "title": "Tennis Analysis CLAUDE.md",
    "section": "",
    "text": "Missing serve data: Many older matches lack serve statistics. Filter with dropna(subset=serve_cols).\nPlayer ID mismatches: Always join on player_id, not name (names can have variants).\nDate parsing: Dates are stored as YYYYMMDD integers. Use format='%Y%m%d' with pd.to_datetime().\nJavaScript in f-strings: When embedding JS in Python f-strings, escape braces {{ and }}. For template literals with ${}, use string concatenation: '.' + tour + '-player' instead of template syntax.\nPlotly in Quarto: Use fig.to_html(full_html=False, include_plotlyjs=False, div_id='unique-id') for charts that need JavaScript interaction. Quarto includes Plotly globally."
  },
  {
    "objectID": "posts/opponent-quality/opponent-quality.html",
    "href": "posts/opponent-quality/opponent-quality.html",
    "title": "Opponent Quality Analysis",
    "section": "",
    "text": "How do elite players perform against different levels of competition? This analysis explores win rates, performance trends, and head-to-head records against opponents categorized by ranking tier.\nOpponent Tiers: - Elite (Top 10): The absolute best in the world - Strong (11-25): Consistent top performers - Solid (26-50): Quality tour players - Mid-tier (51-100): Competitive professionals - Lower (100+): Developing or lower-ranked players\n\n\nShow code\nimport pandas as pd\nimport numpy as np\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport warnings\nwarnings.filterwarnings('ignore')\n\n\n\n\nShow code\n# Load data\natp_matches = pd.read_csv('../../data/top25/atp/atp_top25_matches.csv')\nwta_matches = pd.read_csv('../../data/top25/wta/wta_top25_matches.csv')\natp_players = pd.read_csv('../../data/top25/atp/atp_top25_players.csv')\nwta_players = pd.read_csv('../../data/top25/wta/wta_top25_players.csv')\n\n# Create player name lookup\natp_player_names = dict(zip(atp_players['player_id'], \n                            atp_players['name_first'] + ' ' + atp_players['name_last']))\nwta_player_names = dict(zip(wta_players['player_id'], \n                            wta_players['name_first'] + ' ' + wta_players['name_last']))\n\n# Add tour identifier\natp_matches['tour'] = 'ATP'\nwta_matches['tour'] = 'WTA'\n\nprint(f\"ATP matches: {len(atp_matches):,}\")\nprint(f\"WTA matches: {len(wta_matches):,}\")\n\n\nATP matches: 8,904\nWTA matches: 7,293\n\n\n\n\nShow code\ndef categorize_opponent_tier(rank):\n    \"\"\"Categorize opponent based on their ranking at match time\"\"\"\n    if pd.isna(rank):\n        return 'Unknown'\n    rank = int(rank)\n    if rank &lt;= 10:\n        return 'Elite (1-10)'\n    elif rank &lt;= 25:\n        return 'Strong (11-25)'\n    elif rank &lt;= 50:\n        return 'Solid (26-50)'\n    elif rank &lt;= 100:\n        return 'Mid-tier (51-100)'\n    else:\n        return 'Lower (100+)'\n\ndef process_matches(matches_df, player_ids, player_names):\n    \"\"\"Process matches to create player-centric view with opponent tiers\"\"\"\n    records = []\n    \n    for _, row in matches_df.iterrows():\n        winner_id = row['winner_id']\n        loser_id = row['loser_id']\n        \n        # If winner is in our top 25\n        if winner_id in player_ids:\n            records.append({\n                'player_id': winner_id,\n                'player_name': player_names.get(winner_id, row['winner_name']),\n                'opponent_id': loser_id,\n                'opponent_name': row['loser_name'],\n                'opponent_rank': row['loser_rank'],\n                'opponent_tier': categorize_opponent_tier(row['loser_rank']),\n                'won': 1,\n                'surface': row['surface'],\n                'tourney_level': row['tourney_level'],\n                'tourney_name': row['tourney_name'],\n                'tourney_date': row['tourney_date'],\n                'round': row['round'],\n                'player_rank': row['winner_rank'],\n                'tour': row['tour']\n            })\n        \n        # If loser is in our top 25\n        if loser_id in player_ids:\n            records.append({\n                'player_id': loser_id,\n                'player_name': player_names.get(loser_id, row['loser_name']),\n                'opponent_id': winner_id,\n                'opponent_name': row['winner_name'],\n                'opponent_rank': row['winner_rank'],\n                'opponent_tier': categorize_opponent_tier(row['winner_rank']),\n                'won': 0,\n                'surface': row['surface'],\n                'tourney_level': row['tourney_level'],\n                'tourney_name': row['tourney_name'],\n                'tourney_date': row['tourney_date'],\n                'round': row['round'],\n                'player_rank': row['loser_rank'],\n                'tour': row['tour']\n            })\n    \n    return pd.DataFrame(records)\n\n# Process both tours\natp_player_ids = set(atp_players['player_id'])\nwta_player_ids = set(wta_players['player_id'])\n\natp_records = process_matches(atp_matches, atp_player_ids, atp_player_names)\nwta_records = process_matches(wta_matches, wta_player_ids, wta_player_names)\n\n# Parse dates\natp_records['date'] = pd.to_datetime(atp_records['tourney_date'], format='%Y%m%d')\nwta_records['date'] = pd.to_datetime(wta_records['tourney_date'], format='%Y%m%d')\n\n# Combine\nall_records = pd.concat([atp_records, wta_records], ignore_index=True)\n\nprint(f\"ATP player match records: {len(atp_records):,}\")\nprint(f\"WTA player match records: {len(wta_records):,}\")\n\n\nATP player match records: 10,091\nWTA player match records: 8,136\n\n\n\n\nThis heatmap shows each playerâ€™s win percentage against different tiers of opponents. Darker colors indicate higher win rates. Numbers in cells show match counts for context.\n\n\nShow code\ndef create_tier_heatmap(records_df, title, min_matches=5):\n    \"\"\"Create a heatmap of win rates by opponent tier\"\"\"\n    # Filter out unknown tiers\n    df = records_df[records_df['opponent_tier'] != 'Unknown'].copy()\n    \n    # Calculate win rates by player and tier\n    tier_stats = df.groupby(['player_name', 'opponent_tier']).agg(\n        wins=('won', 'sum'),\n        matches=('won', 'count')\n    ).reset_index()\n    tier_stats['win_pct'] = (tier_stats['wins'] / tier_stats['matches'] * 100).round(1)\n    \n    # Get overall win rate for sorting\n    overall = df.groupby('player_name').agg(\n        total_wins=('won', 'sum'),\n        total_matches=('won', 'count')\n    ).reset_index()\n    overall['overall_win_pct'] = overall['total_wins'] / overall['total_matches']\n    \n    # Pivot for heatmap\n    tier_order = ['Elite (1-10)', 'Strong (11-25)', 'Solid (26-50)', 'Mid-tier (51-100)', 'Lower (100+)']\n    \n    pivot_pct = tier_stats.pivot(index='player_name', columns='opponent_tier', values='win_pct')\n    pivot_matches = tier_stats.pivot(index='player_name', columns='opponent_tier', values='matches')\n    \n    # Reorder columns\n    pivot_pct = pivot_pct[[c for c in tier_order if c in pivot_pct.columns]]\n    pivot_matches = pivot_matches[[c for c in tier_order if c in pivot_matches.columns]]\n    \n    # Sort by overall win rate\n    player_order = overall.sort_values('overall_win_pct', ascending=True)['player_name'].tolist()\n    pivot_pct = pivot_pct.reindex([p for p in player_order if p in pivot_pct.index])\n    pivot_matches = pivot_matches.reindex([p for p in player_order if p in pivot_matches.index])\n    \n    # Create annotations with match counts\n    annotations = []\n    for i, player in enumerate(pivot_pct.index):\n        for j, tier in enumerate(pivot_pct.columns):\n            pct = pivot_pct.loc[player, tier]\n            matches = pivot_matches.loc[player, tier]\n            if pd.notna(pct) and pd.notna(matches) and matches &gt;= min_matches:\n                text = f\"{pct:.0f}%&lt;br&gt;({int(matches)})\"\n            elif pd.notna(matches) and matches &gt; 0:\n                text = f\"({int(matches)})\"\n            else:\n                text = \"\"\n            annotations.append(\n                dict(\n                    x=tier, y=player,\n                    text=text,\n                    showarrow=False,\n                    font=dict(size=9, color='white' if (pd.notna(pct) and pct &gt; 60) else 'black')\n                )\n            )\n    \n    # Mask cells with too few matches\n    masked_pct = pivot_pct.copy()\n    masked_pct[pivot_matches &lt; min_matches] = np.nan\n    \n    fig = go.Figure(data=go.Heatmap(\n        z=masked_pct.values,\n        x=masked_pct.columns.tolist(),\n        y=masked_pct.index.tolist(),\n        colorscale='RdYlGn',\n        zmin=0,\n        zmax=100,\n        colorbar=dict(title='Win %', ticksuffix='%'),\n        hovertemplate='Player: %{y}&lt;br&gt;Tier: %{x}&lt;br&gt;Win Rate: %{z:.1f}%&lt;extra&gt;&lt;/extra&gt;'\n    ))\n    \n    fig.update_layout(\n        title=dict(text=title, font=dict(size=16)),\n        xaxis_title='Opponent Tier',\n        yaxis_title='Player',\n        height=700,\n        annotations=annotations\n    )\n    \n    return fig\n\n# Create heatmaps for both tours\nfig_atp = create_tier_heatmap(atp_records, 'ATP: Win Rate by Opponent Tier')\nfig_atp.show()\n\n\n        \n        \n        \n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_wta = create_tier_heatmap(wta_records, 'WTA: Win Rate by Opponent Tier')\nfig_wta.show()\n\n\n                            \n                                            \n\n\n\n\n\nThis scatter plot compares actual win rates against expected win rates based on ranking differential. Players above the diagonal are overperformers (winning more than expected), while those below are underperformers.\n\n\nShow code\ndef expected_win_prob(player_rank, opponent_rank):\n    \"\"\"Calculate expected win probability based on ranking differential\n    Using a simplified Elo-style model based on rank difference\"\"\"\n    if pd.isna(player_rank) or pd.isna(opponent_rank):\n        return 0.5\n    # Use log-rank difference for better scaling\n    rank_diff = np.log(opponent_rank) - np.log(player_rank)\n    # Sigmoid function to convert to probability\n    return 1 / (1 + np.exp(-rank_diff * 0.8))\n\ndef create_expected_vs_actual(records_df, title, min_matches=30):\n    \"\"\"Create scatter plot of expected vs actual performance\"\"\"\n    df = records_df.copy()\n    df = df[df['opponent_rank'].notna() & df['player_rank'].notna()]\n    \n    # Calculate expected win probability for each match\n    df['expected_win'] = df.apply(\n        lambda x: expected_win_prob(x['player_rank'], x['opponent_rank']), axis=1\n    )\n    \n    # Aggregate by player\n    player_stats = df.groupby('player_name').agg(\n        actual_wins=('won', 'sum'),\n        expected_wins=('expected_win', 'sum'),\n        matches=('won', 'count')\n    ).reset_index()\n    \n    player_stats['actual_pct'] = player_stats['actual_wins'] / player_stats['matches'] * 100\n    player_stats['expected_pct'] = player_stats['expected_wins'] / player_stats['matches'] * 100\n    player_stats['delta'] = player_stats['actual_pct'] - player_stats['expected_pct']\n    \n    # Filter by minimum matches\n    player_stats = player_stats[player_stats['matches'] &gt;= min_matches]\n    \n    # Create scatter plot\n    fig = px.scatter(\n        player_stats,\n        x='expected_pct',\n        y='actual_pct',\n        text='player_name',\n        size='matches',\n        color='delta',\n        color_continuous_scale='RdYlGn',\n        color_continuous_midpoint=0,\n        hover_data={'matches': True, 'delta': ':.1f'},\n        labels={\n            'expected_pct': 'Expected Win %',\n            'actual_pct': 'Actual Win %',\n            'delta': 'Performance Delta',\n            'matches': 'Total Matches'\n        },\n        title=title\n    )\n    \n    # Add diagonal line (y = x)\n    fig.add_trace(go.Scatter(\n        x=[40, 100], y=[40, 100],\n        mode='lines',\n        line=dict(dash='dash', color='gray'),\n        name='Expected = Actual',\n        showlegend=False  # Hide from legend - line is self-explanatory\n    ))\n\n    fig.update_traces(\n        textposition='top center',\n        selector=dict(mode='markers+text')\n    )\n\n    fig.update_layout(\n        height=600,\n        xaxis=dict(range=[40, 100]),\n        yaxis=dict(range=[40, 100])\n    )\n    \n    return fig\n\nfig_exp_atp = create_expected_vs_actual(atp_records, 'ATP: Expected vs Actual Win Rate')\nfig_exp_atp.show()\n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_exp_wta = create_expected_vs_actual(wta_records, 'WTA: Expected vs Actual Win Rate')\nfig_exp_wta.show()\n\n\n                            \n                                            \n\n\n\n\n\nThis chart shows how each playerâ€™s win rate changes as opponent quality increases. Flat lines indicate â€œelite beatersâ€ who maintain performance against top opponents. Steep drop-offs indicate â€œstat paddersâ€ who dominate weaker opponents but struggle vs the best.\n\n\nShow code\ndef create_dropoff_chart(records_df, title, highlight_player=None, min_matches=5):\n    \"\"\"Create line chart showing win rate across opponent tiers\"\"\"\n    df = records_df[records_df['opponent_tier'] != 'Unknown'].copy()\n    \n    tier_order = ['Lower (100+)', 'Mid-tier (51-100)', 'Solid (26-50)', 'Strong (11-25)', 'Elite (1-10)']\n    \n    # Calculate win rates\n    tier_stats = df.groupby(['player_name', 'opponent_tier']).agg(\n        wins=('won', 'sum'),\n        matches=('won', 'count')\n    ).reset_index()\n    tier_stats['win_pct'] = tier_stats['wins'] / tier_stats['matches'] * 100\n    \n    # Filter by min matches per tier\n    tier_stats = tier_stats[tier_stats['matches'] &gt;= min_matches]\n    \n    # Order tiers\n    tier_stats['tier_order'] = tier_stats['opponent_tier'].map({t: i for i, t in enumerate(tier_order)})\n    tier_stats = tier_stats.sort_values(['player_name', 'tier_order'])\n    \n    fig = go.Figure()\n    \n    players = tier_stats['player_name'].unique()\n    \n    for player in players:\n        player_data = tier_stats[tier_stats['player_name'] == player]\n        is_highlighted = highlight_player and player == highlight_player\n        \n        fig.add_trace(go.Scatter(\n            x=player_data['opponent_tier'],\n            y=player_data['win_pct'],\n            mode='lines+markers',\n            name=player,\n            line=dict(\n                width=3 if is_highlighted else 1,\n                color='red' if is_highlighted else 'rgba(150,150,150,0.3)'\n            ),\n            marker=dict(size=8 if is_highlighted else 4),\n            hovertemplate=f'{player}&lt;br&gt;Tier: %{{x}}&lt;br&gt;Win Rate: %{{y:.1f}}%&lt;extra&gt;&lt;/extra&gt;',\n            visible=True,\n            legendgroup=player\n        ))\n    \n    # Create dropdown for player selection\n    buttons = [dict(\n        label='All Players',\n        method='update',\n        args=[{'line.width': [1] * len(players),\n               'line.color': ['rgba(150,150,150,0.5)'] * len(players)}]\n    )]\n    \n    for i, player in enumerate(players):\n        widths = [1] * len(players)\n        colors = ['rgba(150,150,150,0.3)'] * len(players)\n        widths[i] = 4\n        colors[i] = 'red'\n        buttons.append(dict(\n            label=player,\n            method='update',\n            args=[{'line.width': widths, 'line.color': colors}]\n        ))\n    \n    fig.update_layout(\n        title=title,\n        xaxis_title='Opponent Tier (Weakest â†’ Strongest)',\n        yaxis_title='Win Rate (%)',\n        height=600,\n        showlegend=False,\n        updatemenus=[dict(\n            active=0,\n            buttons=buttons,\n            x=1.0,\n            xanchor='right',\n            y=1.02,\n            yanchor='bottom',\n            showactive=True,\n            bgcolor='rgba(255,255,255,0.9)',\n            bordercolor='#ccc',\n            borderwidth=1,\n            font=dict(size=11),\n            pad=dict(l=10, t=10)\n        )],\n        xaxis=dict(categoryorder='array', categoryarray=tier_order),\n        margin=dict(t=80)\n    )\n    \n    return fig\n\nfig_dropoff_atp = create_dropoff_chart(atp_records, 'ATP: Performance Drop-off by Opponent Tier')\nfig_dropoff_atp.show()\n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_dropoff_wta = create_dropoff_chart(wta_records, 'WTA: Performance Drop-off by Opponent Tier')\nfig_dropoff_wta.show()\n\n\n                            \n                                            \n\n\n\n\n\nWhich players face the toughest competition? This chart shows the average opponent ranking faced by each player.\n\n\nShow code\ndef create_strength_of_schedule(records_df, title):\n    \"\"\"Create bar chart of average opponent ranking\"\"\"\n    df = records_df[records_df['opponent_rank'].notna()].copy()\n    \n    # Calculate stats\n    sos_stats = df.groupby('player_name').agg(\n        avg_opp_rank=('opponent_rank', 'mean'),\n        median_opp_rank=('opponent_rank', 'median'),\n        matches=('won', 'count'),\n        wins=('won', 'sum')\n    ).reset_index()\n    sos_stats['win_pct'] = sos_stats['wins'] / sos_stats['matches'] * 100\n    \n    # Sort by average opponent rank (lower = tougher schedule)\n    sos_stats = sos_stats.sort_values('avg_opp_rank')\n    \n    fig = go.Figure()\n    \n    fig.add_trace(go.Bar(\n        x=sos_stats['player_name'],\n        y=sos_stats['avg_opp_rank'],\n        marker_color=sos_stats['win_pct'],\n        marker_colorscale='RdYlGn',\n        marker_cmin=50,\n        marker_cmax=90,\n        marker_colorbar=dict(title='Win %'),\n        hovertemplate='&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;' +\n                      'Avg Opp Rank: %{y:.1f}&lt;br&gt;' +\n                      'Win Rate: %{marker.color:.1f}%&lt;br&gt;' +\n                      '&lt;extra&gt;&lt;/extra&gt;',\n        text=[f\"{r:.0f}\" for r in sos_stats['avg_opp_rank']],\n        textposition='outside'\n    ))\n    \n    fig.update_layout(\n        title=title,\n        xaxis_title='Player',\n        yaxis_title='Average Opponent Ranking',\n        xaxis_tickangle=-45,\n        height=500,\n        yaxis=dict(autorange='reversed')  # Lower rank = tougher, so reverse\n    )\n    \n    return fig\n\nfig_sos_atp = create_strength_of_schedule(atp_records, 'ATP: Strength of Schedule (Avg Opponent Ranking)')\nfig_sos_atp.show()\n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_sos_wta = create_strength_of_schedule(wta_records, 'WTA: Strength of Schedule (Avg Opponent Ranking)')\nfig_sos_wta.show()\n\n\n                            \n                                            \n\n\n\n\n\nWhere do players struggle most? This matrix shows win rates across surface types AND opponent tiers, revealing specific weaknesses like â€œstruggles vs top 10 on hard courtsâ€.\n\n\nShow code\ndef create_surface_tier_matrix(records_df, player_name, title):\n    \"\"\"Create surface x opponent tier matrix for a specific player\"\"\"\n    df = records_df[\n        (records_df['player_name'] == player_name) & \n        (records_df['opponent_tier'] != 'Unknown') &\n        (records_df['surface'].isin(['Hard', 'Clay', 'Grass']))\n    ].copy()\n    \n    if len(df) == 0:\n        return None\n    \n    tier_order = ['Elite (1-10)', 'Strong (11-25)', 'Solid (26-50)', 'Mid-tier (51-100)', 'Lower (100+)']\n    surface_order = ['Hard', 'Clay', 'Grass']\n    \n    # Calculate stats\n    matrix_stats = df.groupby(['surface', 'opponent_tier']).agg(\n        wins=('won', 'sum'),\n        matches=('won', 'count')\n    ).reset_index()\n    matrix_stats['win_pct'] = matrix_stats['wins'] / matrix_stats['matches'] * 100\n    \n    # Pivot\n    pivot_pct = matrix_stats.pivot(index='surface', columns='opponent_tier', values='win_pct')\n    pivot_matches = matrix_stats.pivot(index='surface', columns='opponent_tier', values='matches')\n    \n    # Reorder\n    pivot_pct = pivot_pct.reindex(index=surface_order, columns=tier_order)\n    pivot_matches = pivot_matches.reindex(index=surface_order, columns=tier_order)\n    \n    # Create annotations\n    annotations = []\n    for i, surface in enumerate(pivot_pct.index):\n        for j, tier in enumerate(pivot_pct.columns):\n            pct = pivot_pct.loc[surface, tier]\n            matches = pivot_matches.loc[surface, tier]\n            if pd.notna(pct) and pd.notna(matches) and matches &gt;= 1:\n                text = f\"{pct:.0f}%&lt;br&gt;({int(matches)})\"\n                annotations.append(\n                    dict(x=tier, y=surface, text=text, showarrow=False,\n                         font=dict(size=11, color='white' if pct &gt; 60 else 'black'))\n                )\n    \n    fig = go.Figure(data=go.Heatmap(\n        z=pivot_pct.values,\n        x=pivot_pct.columns.tolist(),\n        y=pivot_pct.index.tolist(),\n        colorscale='RdYlGn',\n        zmin=0,\n        zmax=100,\n        colorbar=dict(title='Win %')\n    ))\n    \n    fig.update_layout(\n        title=f\"{title}: {player_name}\",\n        xaxis_title='Opponent Tier',\n        yaxis_title='Surface',\n        height=350,\n        annotations=annotations\n    )\n    \n    return fig\n\ndef create_surface_tier_comparison(records_df, tour_name, min_matches=20):\n    \"\"\"Create dropdown-based surface x tier comparison\"\"\"\n    players = records_df['player_name'].unique()\n    \n    # Start with first player\n    fig = create_surface_tier_matrix(records_df, players[0], f'{tour_name} Surface x Opponent Tier')\n    \n    # Create dropdown\n    buttons = []\n    for player in sorted(players):\n        df = records_df[\n            (records_df['player_name'] == player) & \n            (records_df['opponent_tier'] != 'Unknown') &\n            (records_df['surface'].isin(['Hard', 'Clay', 'Grass']))\n        ]\n        \n        if len(df) &lt; min_matches:\n            continue\n            \n        tier_order = ['Elite (1-10)', 'Strong (11-25)', 'Solid (26-50)', 'Mid-tier (51-100)', 'Lower (100+)']\n        surface_order = ['Hard', 'Clay', 'Grass']\n        \n        matrix_stats = df.groupby(['surface', 'opponent_tier']).agg(\n            wins=('won', 'sum'),\n            matches=('won', 'count')\n        ).reset_index()\n        matrix_stats['win_pct'] = matrix_stats['wins'] / matrix_stats['matches'] * 100\n        \n        pivot_pct = matrix_stats.pivot(index='surface', columns='opponent_tier', values='win_pct')\n        pivot_pct = pivot_pct.reindex(index=surface_order, columns=tier_order)\n        \n        buttons.append(dict(\n            label=player,\n            method='update',\n            args=[{'z': [pivot_pct.values]},\n                  {'title': f'{tour_name} Surface x Opponent Tier: {player}'}]\n        ))\n    \n    if fig:\n        fig.update_layout(\n            updatemenus=[dict(\n                active=0,\n                buttons=buttons,\n                x=0.0,\n                xanchor='left',\n                y=1.02,\n                yanchor='bottom',\n                bgcolor='rgba(255,255,255,0.9)',\n                bordercolor='#ccc',\n                borderwidth=1,\n                font=dict(size=11),\n                pad=dict(r=10, t=10)\n            )],\n            margin=dict(t=80)\n        )\n    \n    return fig\n\n# Show for top players\nfig_surf_atp = create_surface_tier_comparison(atp_records, 'ATP')\nif fig_surf_atp:\n    fig_surf_atp.show()\n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_surf_wta = create_surface_tier_comparison(wta_records, 'WTA')\nif fig_surf_wta:\n    fig_surf_wta.show()\n\n\n                            \n                                            \n\n\n\n\n\nDo players perform differently at major tournaments? This view compares performance against each opponent tier at different tournament levels: Grand Slams, Masters 1000, and smaller events.\n\n\nShow code\ndef get_tourney_category(level):\n    \"\"\"Categorize tournament level\"\"\"\n    if level == 'G':\n        return 'Grand Slam'\n    elif level == 'M':\n        return 'Masters 1000'\n    elif level in ['A', 'T1', 'T2']:\n        return 'ATP 500/250 (WTA 500+)'\n    else:\n        return 'Other'\n\ndef create_tournament_tier_breakdown(records_df, title, min_matches=3):\n    \"\"\"Create tournament level x opponent tier breakdown\"\"\"\n    df = records_df.copy()\n    df['tourney_category'] = df['tourney_level'].apply(get_tourney_category)\n    df = df[(df['opponent_tier'] != 'Unknown') & (df['tourney_category'] != 'Other')]\n    \n    tier_order = ['Elite (1-10)', 'Strong (11-25)', 'Solid (26-50)', 'Mid-tier (51-100)', 'Lower (100+)']\n    tourney_order = ['Grand Slam', 'Masters 1000', 'ATP 500/250 (WTA 500+)']\n    \n    # Calculate overall stats by tournament category and tier\n    overall_stats = df.groupby(['tourney_category', 'opponent_tier']).agg(\n        wins=('won', 'sum'),\n        matches=('won', 'count')\n    ).reset_index()\n    overall_stats['win_pct'] = overall_stats['wins'] / overall_stats['matches'] * 100\n    \n    # Pivot\n    pivot = overall_stats.pivot(index='tourney_category', columns='opponent_tier', values='win_pct')\n    pivot_matches = overall_stats.pivot(index='tourney_category', columns='opponent_tier', values='matches')\n    \n    pivot = pivot.reindex(index=tourney_order, columns=tier_order)\n    pivot_matches = pivot_matches.reindex(index=tourney_order, columns=tier_order)\n    \n    # Create annotations\n    annotations = []\n    for i, tourney in enumerate(pivot.index):\n        for j, tier in enumerate(pivot.columns):\n            pct = pivot.loc[tourney, tier]\n            matches = pivot_matches.loc[tourney, tier]\n            if pd.notna(pct) and pd.notna(matches) and matches &gt;= min_matches:\n                text = f\"{pct:.0f}%&lt;br&gt;({int(matches)})\"\n                annotations.append(\n                    dict(x=tier, y=tourney, text=text, showarrow=False,\n                         font=dict(size=10, color='white' if pct &gt; 55 else 'black'))\n                )\n    \n    fig = go.Figure(data=go.Heatmap(\n        z=pivot.values,\n        x=pivot.columns.tolist(),\n        y=pivot.index.tolist(),\n        colorscale='RdYlGn',\n        zmin=30,\n        zmax=90,\n        colorbar=dict(title='Win %')\n    ))\n    \n    fig.update_layout(\n        title=f\"{title} - Overall Performance\",\n        xaxis_title='Opponent Tier',\n        yaxis_title='Tournament Level',\n        height=400,\n        annotations=annotations\n    )\n    \n    return fig\n\nfig_tourney_atp = create_tournament_tier_breakdown(atp_records, 'ATP: Tournament Level Breakdown')\nfig_tourney_atp.show()\n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_tourney_wta = create_tournament_tier_breakdown(wta_records, 'WTA: Tournament Level Breakdown')\nfig_tourney_wta.show()\n\n\n                            \n                                            \n\n\n\n\n\nHow has each playerâ€™s performance against top 10 opponents evolved over time? Rising lines indicate improvement; falling lines suggest decline.\n\n\nShow code\ndef create_temporal_trends(records_df, title, min_matches_per_period=3):\n    \"\"\"Create temporal trends of performance vs elite opponents\"\"\"\n    # Filter to elite opponents only\n    df = records_df[records_df['opponent_tier'] == 'Elite (1-10)'].copy()\n    df['year'] = df['date'].dt.year\n    \n    # Calculate yearly win rates\n    yearly_stats = df.groupby(['player_name', 'year']).agg(\n        wins=('won', 'sum'),\n        matches=('won', 'count')\n    ).reset_index()\n    yearly_stats['win_pct'] = yearly_stats['wins'] / yearly_stats['matches'] * 100\n    \n    # Filter periods with minimum matches\n    yearly_stats = yearly_stats[yearly_stats['matches'] &gt;= min_matches_per_period]\n    \n    # Only include players with multiple years of data\n    player_years = yearly_stats.groupby('player_name')['year'].nunique()\n    multi_year_players = player_years[player_years &gt;= 2].index\n    yearly_stats = yearly_stats[yearly_stats['player_name'].isin(multi_year_players)]\n    \n    if len(yearly_stats) == 0:\n        return None\n    \n    fig = px.line(\n        yearly_stats,\n        x='year',\n        y='win_pct',\n        color='player_name',\n        markers=True,\n        hover_data=['matches'],\n        labels={\n            'year': 'Year',\n            'win_pct': 'Win % vs Top 10',\n            'player_name': 'Player',\n            'matches': 'Matches'\n        },\n        title=title\n    )\n    \n    fig.update_layout(\n        height=500,\n        legend=dict(\n            orientation='v',\n            x=1.02,\n            y=1,\n            xanchor='left',\n            yanchor='top',\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='#ccc',\n            borderwidth=1,\n            font=dict(size=10)\n        ),\n        margin=dict(r=150),\n        yaxis=dict(range=[0, 100])\n    )\n    \n    return fig\n\nfig_temporal_atp = create_temporal_trends(atp_records, 'ATP: Win Rate vs Top 10 Over Time')\nif fig_temporal_atp:\n    fig_temporal_atp.show()\n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_temporal_wta = create_temporal_trends(wta_records, 'WTA: Win Rate vs Top 10 Over Time')\nif fig_temporal_wta:\n    fig_temporal_wta.show()\n\n\n                            \n                                            \n\n\n\n\n\nDetailed records against specific top opponents, not just tiers. Filter to show rivalries with 3+ matches and see surface breakdown within each H2H.\n\n\nShow code\ndef create_h2h_matrix(matches_df, player_ids, player_names, title, min_matches=3):\n    \"\"\"Create head-to-head matrix between top 25 players\"\"\"\n    # Build H2H records\n    h2h_records = {}\n    \n    for _, row in matches_df.iterrows():\n        winner_id = row['winner_id']\n        loser_id = row['loser_id']\n        \n        # Only count matches between top 25 players\n        if winner_id in player_ids and loser_id in player_ids:\n            winner_name = player_names.get(winner_id, row['winner_name'])\n            loser_name = player_names.get(loser_id, row['loser_name'])\n            \n            key = tuple(sorted([winner_name, loser_name]))\n            if key not in h2h_records:\n                h2h_records[key] = {'player1': key[0], 'player2': key[1],\n                                    'p1_wins': 0, 'p2_wins': 0,\n                                    'hard_p1': 0, 'hard_p2': 0,\n                                    'clay_p1': 0, 'clay_p2': 0,\n                                    'grass_p1': 0, 'grass_p2': 0}\n            \n            surface = row['surface'].lower() if pd.notna(row['surface']) else 'other'\n            \n            if winner_name == key[0]:\n                h2h_records[key]['p1_wins'] += 1\n                if surface == 'hard':\n                    h2h_records[key]['hard_p1'] += 1\n                elif surface == 'clay':\n                    h2h_records[key]['clay_p1'] += 1\n                elif surface == 'grass':\n                    h2h_records[key]['grass_p1'] += 1\n            else:\n                h2h_records[key]['p2_wins'] += 1\n                if surface == 'hard':\n                    h2h_records[key]['hard_p2'] += 1\n                elif surface == 'clay':\n                    h2h_records[key]['clay_p2'] += 1\n                elif surface == 'grass':\n                    h2h_records[key]['grass_p2'] += 1\n    \n    h2h_df = pd.DataFrame(h2h_records.values())\n    h2h_df['total_matches'] = h2h_df['p1_wins'] + h2h_df['p2_wins']\n    h2h_df = h2h_df[h2h_df['total_matches'] &gt;= min_matches]\n    h2h_df = h2h_df.sort_values('total_matches', ascending=False)\n    \n    if len(h2h_df) == 0:\n        return None\n    \n    # Create display strings\n    h2h_df['h2h'] = h2h_df.apply(lambda x: f\"{x['p1_wins']}-{x['p2_wins']}\", axis=1)\n    h2h_df['hard'] = h2h_df.apply(lambda x: f\"{x['hard_p1']}-{x['hard_p2']}\", axis=1)\n    h2h_df['clay'] = h2h_df.apply(lambda x: f\"{x['clay_p1']}-{x['clay_p2']}\", axis=1)\n    h2h_df['grass'] = h2h_df.apply(lambda x: f\"{x['grass_p1']}-{x['grass_p2']}\", axis=1)\n    h2h_df['matchup'] = h2h_df['player1'] + ' vs ' + h2h_df['player2']\n    \n    # Create table\n    fig = go.Figure(data=[go.Table(\n        header=dict(\n            values=['Matchup', 'H2H', 'Hard', 'Clay', 'Grass', 'Total'],\n            fill_color='#1f77b4',\n            font=dict(color='white', size=12),\n            align='left'\n        ),\n        cells=dict(\n            values=[\n                h2h_df['matchup'],\n                h2h_df['h2h'],\n                h2h_df['hard'],\n                h2h_df['clay'],\n                h2h_df['grass'],\n                h2h_df['total_matches']\n            ],\n            fill_color='white',\n            align='left',\n            height=30\n        )\n    )])\n    \n    fig.update_layout(\n        title=f\"{title} (Minimum {min_matches} matches)\",\n        height=max(400, len(h2h_df) * 35 + 100)\n    )\n    \n    return fig\n\nfig_h2h_atp = create_h2h_matrix(atp_matches, atp_player_ids, atp_player_names, \n                                'ATP: Head-to-Head Records Among Top 25')\nif fig_h2h_atp:\n    fig_h2h_atp.show()\n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_h2h_wta = create_h2h_matrix(wta_matches, wta_player_ids, wta_player_names,\n                                'WTA: Head-to-Head Records Among Top 25')\nif fig_h2h_wta:\n    fig_h2h_wta.show()\n\n\n                            \n                                            \n\n\n\n\n\nKey metrics for each player summarizing their opponent quality performance.\n\n\nShow code\ndef create_summary_table(records_df, title):\n    \"\"\"Create summary statistics table\"\"\"\n    df = records_df.copy()\n    \n    # Overall stats\n    overall = df.groupby('player_name').agg(\n        total_matches=('won', 'count'),\n        total_wins=('won', 'sum'),\n        avg_opp_rank=('opponent_rank', 'mean')\n    ).reset_index()\n    overall['overall_win_pct'] = (overall['total_wins'] / overall['total_matches'] * 100).round(1)\n    overall['avg_opp_rank'] = overall['avg_opp_rank'].round(0)\n    \n    # Elite performance\n    elite = df[df['opponent_tier'] == 'Elite (1-10)'].groupby('player_name').agg(\n        elite_matches=('won', 'count'),\n        elite_wins=('won', 'sum')\n    ).reset_index()\n    elite['elite_win_pct'] = (elite['elite_wins'] / elite['elite_matches'] * 100).round(1)\n    \n    # Merge\n    summary = overall.merge(elite, on='player_name', how='left')\n    summary['elite_win_pct'] = summary['elite_win_pct'].fillna(0)\n    summary['elite_matches'] = summary['elite_matches'].fillna(0).astype(int)\n    \n    # Calculate drop-off (lower tier win% - elite win%)\n    lower = df[df['opponent_tier'] == 'Lower (100+)'].groupby('player_name').agg(\n        lower_wins=('won', 'sum'),\n        lower_matches=('won', 'count')\n    ).reset_index()\n    lower['lower_win_pct'] = lower['lower_wins'] / lower['lower_matches'] * 100\n    \n    summary = summary.merge(lower[['player_name', 'lower_win_pct']], on='player_name', how='left')\n    summary['dropoff'] = (summary['lower_win_pct'] - summary['elite_win_pct']).round(1)\n    \n    summary = summary.sort_values('elite_win_pct', ascending=False)\n    \n    # Create table\n    fig = go.Figure(data=[go.Table(\n        header=dict(\n            values=['Player', 'Matches', 'Win %', 'Avg Opp Rank', 'vs Elite', 'Elite Win %', 'Drop-off'],\n            fill_color='#1f77b4',\n            font=dict(color='white', size=11),\n            align='left'\n        ),\n        cells=dict(\n            values=[\n                summary['player_name'],\n                summary['total_matches'],\n                summary['overall_win_pct'].astype(str) + '%',\n                summary['avg_opp_rank'].astype(int),\n                summary['elite_matches'].astype(str) + ' matches',\n                summary['elite_win_pct'].astype(str) + '%',\n                summary['dropoff'].apply(lambda x: f\"+{x:.0f}%\" if pd.notna(x) else 'N/A')\n            ],\n            fill_color=[['white', '#f0f0f0'] * (len(summary) // 2 + 1)][:len(summary)],\n            align='left',\n            height=28\n        )\n    )])\n    \n    fig.update_layout(\n        title=title,\n        height=max(400, len(summary) * 32 + 100)\n    )\n    \n    return fig\n\nfig_summary_atp = create_summary_table(atp_records, 'ATP: Player Summary Statistics')\nfig_summary_atp.show()\n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_summary_wta = create_summary_table(wta_records, 'WTA: Player Summary Statistics')\nfig_summary_wta.show()\n\n\n                            \n                                            \n\n\n\n\n\nThis analysis reveals several patterns in how players perform against different quality opponents:\n\nElite Beaters: Players with relatively flat drop-off lines maintain strong performance regardless of opponent quality\nStat Padders: Large drop-offs between lower-tier and elite performance may indicate inflated records against weaker opponents\nSurface Specialists: Some players show dramatically different performance by surface when facing top opponents\nBig Stage Performers: Tournament-level breakdown reveals who rises to the occasion at Grand Slams vs smaller events\nTrajectory: Temporal trends show which players are improving or declining against elite competition"
  },
  {
    "objectID": "posts/opponent-quality/opponent-quality.html#view-1-win-rate-by-opponent-tier-heatmap",
    "href": "posts/opponent-quality/opponent-quality.html#view-1-win-rate-by-opponent-tier-heatmap",
    "title": "Opponent Quality Analysis",
    "section": "",
    "text": "This heatmap shows each playerâ€™s win percentage against different tiers of opponents. Darker colors indicate higher win rates. Numbers in cells show match counts for context.\n\n\nShow code\ndef create_tier_heatmap(records_df, title, min_matches=5):\n    \"\"\"Create a heatmap of win rates by opponent tier\"\"\"\n    # Filter out unknown tiers\n    df = records_df[records_df['opponent_tier'] != 'Unknown'].copy()\n    \n    # Calculate win rates by player and tier\n    tier_stats = df.groupby(['player_name', 'opponent_tier']).agg(\n        wins=('won', 'sum'),\n        matches=('won', 'count')\n    ).reset_index()\n    tier_stats['win_pct'] = (tier_stats['wins'] / tier_stats['matches'] * 100).round(1)\n    \n    # Get overall win rate for sorting\n    overall = df.groupby('player_name').agg(\n        total_wins=('won', 'sum'),\n        total_matches=('won', 'count')\n    ).reset_index()\n    overall['overall_win_pct'] = overall['total_wins'] / overall['total_matches']\n    \n    # Pivot for heatmap\n    tier_order = ['Elite (1-10)', 'Strong (11-25)', 'Solid (26-50)', 'Mid-tier (51-100)', 'Lower (100+)']\n    \n    pivot_pct = tier_stats.pivot(index='player_name', columns='opponent_tier', values='win_pct')\n    pivot_matches = tier_stats.pivot(index='player_name', columns='opponent_tier', values='matches')\n    \n    # Reorder columns\n    pivot_pct = pivot_pct[[c for c in tier_order if c in pivot_pct.columns]]\n    pivot_matches = pivot_matches[[c for c in tier_order if c in pivot_matches.columns]]\n    \n    # Sort by overall win rate\n    player_order = overall.sort_values('overall_win_pct', ascending=True)['player_name'].tolist()\n    pivot_pct = pivot_pct.reindex([p for p in player_order if p in pivot_pct.index])\n    pivot_matches = pivot_matches.reindex([p for p in player_order if p in pivot_matches.index])\n    \n    # Create annotations with match counts\n    annotations = []\n    for i, player in enumerate(pivot_pct.index):\n        for j, tier in enumerate(pivot_pct.columns):\n            pct = pivot_pct.loc[player, tier]\n            matches = pivot_matches.loc[player, tier]\n            if pd.notna(pct) and pd.notna(matches) and matches &gt;= min_matches:\n                text = f\"{pct:.0f}%&lt;br&gt;({int(matches)})\"\n            elif pd.notna(matches) and matches &gt; 0:\n                text = f\"({int(matches)})\"\n            else:\n                text = \"\"\n            annotations.append(\n                dict(\n                    x=tier, y=player,\n                    text=text,\n                    showarrow=False,\n                    font=dict(size=9, color='white' if (pd.notna(pct) and pct &gt; 60) else 'black')\n                )\n            )\n    \n    # Mask cells with too few matches\n    masked_pct = pivot_pct.copy()\n    masked_pct[pivot_matches &lt; min_matches] = np.nan\n    \n    fig = go.Figure(data=go.Heatmap(\n        z=masked_pct.values,\n        x=masked_pct.columns.tolist(),\n        y=masked_pct.index.tolist(),\n        colorscale='RdYlGn',\n        zmin=0,\n        zmax=100,\n        colorbar=dict(title='Win %', ticksuffix='%'),\n        hovertemplate='Player: %{y}&lt;br&gt;Tier: %{x}&lt;br&gt;Win Rate: %{z:.1f}%&lt;extra&gt;&lt;/extra&gt;'\n    ))\n    \n    fig.update_layout(\n        title=dict(text=title, font=dict(size=16)),\n        xaxis_title='Opponent Tier',\n        yaxis_title='Player',\n        height=700,\n        annotations=annotations\n    )\n    \n    return fig\n\n# Create heatmaps for both tours\nfig_atp = create_tier_heatmap(atp_records, 'ATP: Win Rate by Opponent Tier')\nfig_atp.show()\n\n\n        \n        \n        \n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_wta = create_tier_heatmap(wta_records, 'WTA: Win Rate by Opponent Tier')\nfig_wta.show()"
  },
  {
    "objectID": "posts/opponent-quality/opponent-quality.html#view-2-expected-vs-actual-performance",
    "href": "posts/opponent-quality/opponent-quality.html#view-2-expected-vs-actual-performance",
    "title": "Opponent Quality Analysis",
    "section": "",
    "text": "This scatter plot compares actual win rates against expected win rates based on ranking differential. Players above the diagonal are overperformers (winning more than expected), while those below are underperformers.\n\n\nShow code\ndef expected_win_prob(player_rank, opponent_rank):\n    \"\"\"Calculate expected win probability based on ranking differential\n    Using a simplified Elo-style model based on rank difference\"\"\"\n    if pd.isna(player_rank) or pd.isna(opponent_rank):\n        return 0.5\n    # Use log-rank difference for better scaling\n    rank_diff = np.log(opponent_rank) - np.log(player_rank)\n    # Sigmoid function to convert to probability\n    return 1 / (1 + np.exp(-rank_diff * 0.8))\n\ndef create_expected_vs_actual(records_df, title, min_matches=30):\n    \"\"\"Create scatter plot of expected vs actual performance\"\"\"\n    df = records_df.copy()\n    df = df[df['opponent_rank'].notna() & df['player_rank'].notna()]\n    \n    # Calculate expected win probability for each match\n    df['expected_win'] = df.apply(\n        lambda x: expected_win_prob(x['player_rank'], x['opponent_rank']), axis=1\n    )\n    \n    # Aggregate by player\n    player_stats = df.groupby('player_name').agg(\n        actual_wins=('won', 'sum'),\n        expected_wins=('expected_win', 'sum'),\n        matches=('won', 'count')\n    ).reset_index()\n    \n    player_stats['actual_pct'] = player_stats['actual_wins'] / player_stats['matches'] * 100\n    player_stats['expected_pct'] = player_stats['expected_wins'] / player_stats['matches'] * 100\n    player_stats['delta'] = player_stats['actual_pct'] - player_stats['expected_pct']\n    \n    # Filter by minimum matches\n    player_stats = player_stats[player_stats['matches'] &gt;= min_matches]\n    \n    # Create scatter plot\n    fig = px.scatter(\n        player_stats,\n        x='expected_pct',\n        y='actual_pct',\n        text='player_name',\n        size='matches',\n        color='delta',\n        color_continuous_scale='RdYlGn',\n        color_continuous_midpoint=0,\n        hover_data={'matches': True, 'delta': ':.1f'},\n        labels={\n            'expected_pct': 'Expected Win %',\n            'actual_pct': 'Actual Win %',\n            'delta': 'Performance Delta',\n            'matches': 'Total Matches'\n        },\n        title=title\n    )\n    \n    # Add diagonal line (y = x)\n    fig.add_trace(go.Scatter(\n        x=[40, 100], y=[40, 100],\n        mode='lines',\n        line=dict(dash='dash', color='gray'),\n        name='Expected = Actual',\n        showlegend=False  # Hide from legend - line is self-explanatory\n    ))\n\n    fig.update_traces(\n        textposition='top center',\n        selector=dict(mode='markers+text')\n    )\n\n    fig.update_layout(\n        height=600,\n        xaxis=dict(range=[40, 100]),\n        yaxis=dict(range=[40, 100])\n    )\n    \n    return fig\n\nfig_exp_atp = create_expected_vs_actual(atp_records, 'ATP: Expected vs Actual Win Rate')\nfig_exp_atp.show()\n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_exp_wta = create_expected_vs_actual(wta_records, 'WTA: Expected vs Actual Win Rate')\nfig_exp_wta.show()"
  },
  {
    "objectID": "posts/opponent-quality/opponent-quality.html#view-3-performance-drop-off-lines",
    "href": "posts/opponent-quality/opponent-quality.html#view-3-performance-drop-off-lines",
    "title": "Opponent Quality Analysis",
    "section": "",
    "text": "This chart shows how each playerâ€™s win rate changes as opponent quality increases. Flat lines indicate â€œelite beatersâ€ who maintain performance against top opponents. Steep drop-offs indicate â€œstat paddersâ€ who dominate weaker opponents but struggle vs the best.\n\n\nShow code\ndef create_dropoff_chart(records_df, title, highlight_player=None, min_matches=5):\n    \"\"\"Create line chart showing win rate across opponent tiers\"\"\"\n    df = records_df[records_df['opponent_tier'] != 'Unknown'].copy()\n    \n    tier_order = ['Lower (100+)', 'Mid-tier (51-100)', 'Solid (26-50)', 'Strong (11-25)', 'Elite (1-10)']\n    \n    # Calculate win rates\n    tier_stats = df.groupby(['player_name', 'opponent_tier']).agg(\n        wins=('won', 'sum'),\n        matches=('won', 'count')\n    ).reset_index()\n    tier_stats['win_pct'] = tier_stats['wins'] / tier_stats['matches'] * 100\n    \n    # Filter by min matches per tier\n    tier_stats = tier_stats[tier_stats['matches'] &gt;= min_matches]\n    \n    # Order tiers\n    tier_stats['tier_order'] = tier_stats['opponent_tier'].map({t: i for i, t in enumerate(tier_order)})\n    tier_stats = tier_stats.sort_values(['player_name', 'tier_order'])\n    \n    fig = go.Figure()\n    \n    players = tier_stats['player_name'].unique()\n    \n    for player in players:\n        player_data = tier_stats[tier_stats['player_name'] == player]\n        is_highlighted = highlight_player and player == highlight_player\n        \n        fig.add_trace(go.Scatter(\n            x=player_data['opponent_tier'],\n            y=player_data['win_pct'],\n            mode='lines+markers',\n            name=player,\n            line=dict(\n                width=3 if is_highlighted else 1,\n                color='red' if is_highlighted else 'rgba(150,150,150,0.3)'\n            ),\n            marker=dict(size=8 if is_highlighted else 4),\n            hovertemplate=f'{player}&lt;br&gt;Tier: %{{x}}&lt;br&gt;Win Rate: %{{y:.1f}}%&lt;extra&gt;&lt;/extra&gt;',\n            visible=True,\n            legendgroup=player\n        ))\n    \n    # Create dropdown for player selection\n    buttons = [dict(\n        label='All Players',\n        method='update',\n        args=[{'line.width': [1] * len(players),\n               'line.color': ['rgba(150,150,150,0.5)'] * len(players)}]\n    )]\n    \n    for i, player in enumerate(players):\n        widths = [1] * len(players)\n        colors = ['rgba(150,150,150,0.3)'] * len(players)\n        widths[i] = 4\n        colors[i] = 'red'\n        buttons.append(dict(\n            label=player,\n            method='update',\n            args=[{'line.width': widths, 'line.color': colors}]\n        ))\n    \n    fig.update_layout(\n        title=title,\n        xaxis_title='Opponent Tier (Weakest â†’ Strongest)',\n        yaxis_title='Win Rate (%)',\n        height=600,\n        showlegend=False,\n        updatemenus=[dict(\n            active=0,\n            buttons=buttons,\n            x=1.0,\n            xanchor='right',\n            y=1.02,\n            yanchor='bottom',\n            showactive=True,\n            bgcolor='rgba(255,255,255,0.9)',\n            bordercolor='#ccc',\n            borderwidth=1,\n            font=dict(size=11),\n            pad=dict(l=10, t=10)\n        )],\n        xaxis=dict(categoryorder='array', categoryarray=tier_order),\n        margin=dict(t=80)\n    )\n    \n    return fig\n\nfig_dropoff_atp = create_dropoff_chart(atp_records, 'ATP: Performance Drop-off by Opponent Tier')\nfig_dropoff_atp.show()\n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_dropoff_wta = create_dropoff_chart(wta_records, 'WTA: Performance Drop-off by Opponent Tier')\nfig_dropoff_wta.show()"
  },
  {
    "objectID": "posts/opponent-quality/opponent-quality.html#view-4-strength-of-schedule",
    "href": "posts/opponent-quality/opponent-quality.html#view-4-strength-of-schedule",
    "title": "Opponent Quality Analysis",
    "section": "",
    "text": "Which players face the toughest competition? This chart shows the average opponent ranking faced by each player.\n\n\nShow code\ndef create_strength_of_schedule(records_df, title):\n    \"\"\"Create bar chart of average opponent ranking\"\"\"\n    df = records_df[records_df['opponent_rank'].notna()].copy()\n    \n    # Calculate stats\n    sos_stats = df.groupby('player_name').agg(\n        avg_opp_rank=('opponent_rank', 'mean'),\n        median_opp_rank=('opponent_rank', 'median'),\n        matches=('won', 'count'),\n        wins=('won', 'sum')\n    ).reset_index()\n    sos_stats['win_pct'] = sos_stats['wins'] / sos_stats['matches'] * 100\n    \n    # Sort by average opponent rank (lower = tougher schedule)\n    sos_stats = sos_stats.sort_values('avg_opp_rank')\n    \n    fig = go.Figure()\n    \n    fig.add_trace(go.Bar(\n        x=sos_stats['player_name'],\n        y=sos_stats['avg_opp_rank'],\n        marker_color=sos_stats['win_pct'],\n        marker_colorscale='RdYlGn',\n        marker_cmin=50,\n        marker_cmax=90,\n        marker_colorbar=dict(title='Win %'),\n        hovertemplate='&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;' +\n                      'Avg Opp Rank: %{y:.1f}&lt;br&gt;' +\n                      'Win Rate: %{marker.color:.1f}%&lt;br&gt;' +\n                      '&lt;extra&gt;&lt;/extra&gt;',\n        text=[f\"{r:.0f}\" for r in sos_stats['avg_opp_rank']],\n        textposition='outside'\n    ))\n    \n    fig.update_layout(\n        title=title,\n        xaxis_title='Player',\n        yaxis_title='Average Opponent Ranking',\n        xaxis_tickangle=-45,\n        height=500,\n        yaxis=dict(autorange='reversed')  # Lower rank = tougher, so reverse\n    )\n    \n    return fig\n\nfig_sos_atp = create_strength_of_schedule(atp_records, 'ATP: Strength of Schedule (Avg Opponent Ranking)')\nfig_sos_atp.show()\n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_sos_wta = create_strength_of_schedule(wta_records, 'WTA: Strength of Schedule (Avg Opponent Ranking)')\nfig_sos_wta.show()"
  },
  {
    "objectID": "posts/opponent-quality/opponent-quality.html#view-5-surface-x-opponent-quality-matrix",
    "href": "posts/opponent-quality/opponent-quality.html#view-5-surface-x-opponent-quality-matrix",
    "title": "Opponent Quality Analysis",
    "section": "",
    "text": "Where do players struggle most? This matrix shows win rates across surface types AND opponent tiers, revealing specific weaknesses like â€œstruggles vs top 10 on hard courtsâ€.\n\n\nShow code\ndef create_surface_tier_matrix(records_df, player_name, title):\n    \"\"\"Create surface x opponent tier matrix for a specific player\"\"\"\n    df = records_df[\n        (records_df['player_name'] == player_name) & \n        (records_df['opponent_tier'] != 'Unknown') &\n        (records_df['surface'].isin(['Hard', 'Clay', 'Grass']))\n    ].copy()\n    \n    if len(df) == 0:\n        return None\n    \n    tier_order = ['Elite (1-10)', 'Strong (11-25)', 'Solid (26-50)', 'Mid-tier (51-100)', 'Lower (100+)']\n    surface_order = ['Hard', 'Clay', 'Grass']\n    \n    # Calculate stats\n    matrix_stats = df.groupby(['surface', 'opponent_tier']).agg(\n        wins=('won', 'sum'),\n        matches=('won', 'count')\n    ).reset_index()\n    matrix_stats['win_pct'] = matrix_stats['wins'] / matrix_stats['matches'] * 100\n    \n    # Pivot\n    pivot_pct = matrix_stats.pivot(index='surface', columns='opponent_tier', values='win_pct')\n    pivot_matches = matrix_stats.pivot(index='surface', columns='opponent_tier', values='matches')\n    \n    # Reorder\n    pivot_pct = pivot_pct.reindex(index=surface_order, columns=tier_order)\n    pivot_matches = pivot_matches.reindex(index=surface_order, columns=tier_order)\n    \n    # Create annotations\n    annotations = []\n    for i, surface in enumerate(pivot_pct.index):\n        for j, tier in enumerate(pivot_pct.columns):\n            pct = pivot_pct.loc[surface, tier]\n            matches = pivot_matches.loc[surface, tier]\n            if pd.notna(pct) and pd.notna(matches) and matches &gt;= 1:\n                text = f\"{pct:.0f}%&lt;br&gt;({int(matches)})\"\n                annotations.append(\n                    dict(x=tier, y=surface, text=text, showarrow=False,\n                         font=dict(size=11, color='white' if pct &gt; 60 else 'black'))\n                )\n    \n    fig = go.Figure(data=go.Heatmap(\n        z=pivot_pct.values,\n        x=pivot_pct.columns.tolist(),\n        y=pivot_pct.index.tolist(),\n        colorscale='RdYlGn',\n        zmin=0,\n        zmax=100,\n        colorbar=dict(title='Win %')\n    ))\n    \n    fig.update_layout(\n        title=f\"{title}: {player_name}\",\n        xaxis_title='Opponent Tier',\n        yaxis_title='Surface',\n        height=350,\n        annotations=annotations\n    )\n    \n    return fig\n\ndef create_surface_tier_comparison(records_df, tour_name, min_matches=20):\n    \"\"\"Create dropdown-based surface x tier comparison\"\"\"\n    players = records_df['player_name'].unique()\n    \n    # Start with first player\n    fig = create_surface_tier_matrix(records_df, players[0], f'{tour_name} Surface x Opponent Tier')\n    \n    # Create dropdown\n    buttons = []\n    for player in sorted(players):\n        df = records_df[\n            (records_df['player_name'] == player) & \n            (records_df['opponent_tier'] != 'Unknown') &\n            (records_df['surface'].isin(['Hard', 'Clay', 'Grass']))\n        ]\n        \n        if len(df) &lt; min_matches:\n            continue\n            \n        tier_order = ['Elite (1-10)', 'Strong (11-25)', 'Solid (26-50)', 'Mid-tier (51-100)', 'Lower (100+)']\n        surface_order = ['Hard', 'Clay', 'Grass']\n        \n        matrix_stats = df.groupby(['surface', 'opponent_tier']).agg(\n            wins=('won', 'sum'),\n            matches=('won', 'count')\n        ).reset_index()\n        matrix_stats['win_pct'] = matrix_stats['wins'] / matrix_stats['matches'] * 100\n        \n        pivot_pct = matrix_stats.pivot(index='surface', columns='opponent_tier', values='win_pct')\n        pivot_pct = pivot_pct.reindex(index=surface_order, columns=tier_order)\n        \n        buttons.append(dict(\n            label=player,\n            method='update',\n            args=[{'z': [pivot_pct.values]},\n                  {'title': f'{tour_name} Surface x Opponent Tier: {player}'}]\n        ))\n    \n    if fig:\n        fig.update_layout(\n            updatemenus=[dict(\n                active=0,\n                buttons=buttons,\n                x=0.0,\n                xanchor='left',\n                y=1.02,\n                yanchor='bottom',\n                bgcolor='rgba(255,255,255,0.9)',\n                bordercolor='#ccc',\n                borderwidth=1,\n                font=dict(size=11),\n                pad=dict(r=10, t=10)\n            )],\n            margin=dict(t=80)\n        )\n    \n    return fig\n\n# Show for top players\nfig_surf_atp = create_surface_tier_comparison(atp_records, 'ATP')\nif fig_surf_atp:\n    fig_surf_atp.show()\n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_surf_wta = create_surface_tier_comparison(wta_records, 'WTA')\nif fig_surf_wta:\n    fig_surf_wta.show()"
  },
  {
    "objectID": "posts/opponent-quality/opponent-quality.html#view-6-tournament-level-breakdown",
    "href": "posts/opponent-quality/opponent-quality.html#view-6-tournament-level-breakdown",
    "title": "Opponent Quality Analysis",
    "section": "",
    "text": "Do players perform differently at major tournaments? This view compares performance against each opponent tier at different tournament levels: Grand Slams, Masters 1000, and smaller events.\n\n\nShow code\ndef get_tourney_category(level):\n    \"\"\"Categorize tournament level\"\"\"\n    if level == 'G':\n        return 'Grand Slam'\n    elif level == 'M':\n        return 'Masters 1000'\n    elif level in ['A', 'T1', 'T2']:\n        return 'ATP 500/250 (WTA 500+)'\n    else:\n        return 'Other'\n\ndef create_tournament_tier_breakdown(records_df, title, min_matches=3):\n    \"\"\"Create tournament level x opponent tier breakdown\"\"\"\n    df = records_df.copy()\n    df['tourney_category'] = df['tourney_level'].apply(get_tourney_category)\n    df = df[(df['opponent_tier'] != 'Unknown') & (df['tourney_category'] != 'Other')]\n    \n    tier_order = ['Elite (1-10)', 'Strong (11-25)', 'Solid (26-50)', 'Mid-tier (51-100)', 'Lower (100+)']\n    tourney_order = ['Grand Slam', 'Masters 1000', 'ATP 500/250 (WTA 500+)']\n    \n    # Calculate overall stats by tournament category and tier\n    overall_stats = df.groupby(['tourney_category', 'opponent_tier']).agg(\n        wins=('won', 'sum'),\n        matches=('won', 'count')\n    ).reset_index()\n    overall_stats['win_pct'] = overall_stats['wins'] / overall_stats['matches'] * 100\n    \n    # Pivot\n    pivot = overall_stats.pivot(index='tourney_category', columns='opponent_tier', values='win_pct')\n    pivot_matches = overall_stats.pivot(index='tourney_category', columns='opponent_tier', values='matches')\n    \n    pivot = pivot.reindex(index=tourney_order, columns=tier_order)\n    pivot_matches = pivot_matches.reindex(index=tourney_order, columns=tier_order)\n    \n    # Create annotations\n    annotations = []\n    for i, tourney in enumerate(pivot.index):\n        for j, tier in enumerate(pivot.columns):\n            pct = pivot.loc[tourney, tier]\n            matches = pivot_matches.loc[tourney, tier]\n            if pd.notna(pct) and pd.notna(matches) and matches &gt;= min_matches:\n                text = f\"{pct:.0f}%&lt;br&gt;({int(matches)})\"\n                annotations.append(\n                    dict(x=tier, y=tourney, text=text, showarrow=False,\n                         font=dict(size=10, color='white' if pct &gt; 55 else 'black'))\n                )\n    \n    fig = go.Figure(data=go.Heatmap(\n        z=pivot.values,\n        x=pivot.columns.tolist(),\n        y=pivot.index.tolist(),\n        colorscale='RdYlGn',\n        zmin=30,\n        zmax=90,\n        colorbar=dict(title='Win %')\n    ))\n    \n    fig.update_layout(\n        title=f\"{title} - Overall Performance\",\n        xaxis_title='Opponent Tier',\n        yaxis_title='Tournament Level',\n        height=400,\n        annotations=annotations\n    )\n    \n    return fig\n\nfig_tourney_atp = create_tournament_tier_breakdown(atp_records, 'ATP: Tournament Level Breakdown')\nfig_tourney_atp.show()\n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_tourney_wta = create_tournament_tier_breakdown(wta_records, 'WTA: Tournament Level Breakdown')\nfig_tourney_wta.show()"
  },
  {
    "objectID": "posts/opponent-quality/opponent-quality.html#view-7-temporal-trends-performance-vs-elite-over-time",
    "href": "posts/opponent-quality/opponent-quality.html#view-7-temporal-trends-performance-vs-elite-over-time",
    "title": "Opponent Quality Analysis",
    "section": "",
    "text": "How has each playerâ€™s performance against top 10 opponents evolved over time? Rising lines indicate improvement; falling lines suggest decline.\n\n\nShow code\ndef create_temporal_trends(records_df, title, min_matches_per_period=3):\n    \"\"\"Create temporal trends of performance vs elite opponents\"\"\"\n    # Filter to elite opponents only\n    df = records_df[records_df['opponent_tier'] == 'Elite (1-10)'].copy()\n    df['year'] = df['date'].dt.year\n    \n    # Calculate yearly win rates\n    yearly_stats = df.groupby(['player_name', 'year']).agg(\n        wins=('won', 'sum'),\n        matches=('won', 'count')\n    ).reset_index()\n    yearly_stats['win_pct'] = yearly_stats['wins'] / yearly_stats['matches'] * 100\n    \n    # Filter periods with minimum matches\n    yearly_stats = yearly_stats[yearly_stats['matches'] &gt;= min_matches_per_period]\n    \n    # Only include players with multiple years of data\n    player_years = yearly_stats.groupby('player_name')['year'].nunique()\n    multi_year_players = player_years[player_years &gt;= 2].index\n    yearly_stats = yearly_stats[yearly_stats['player_name'].isin(multi_year_players)]\n    \n    if len(yearly_stats) == 0:\n        return None\n    \n    fig = px.line(\n        yearly_stats,\n        x='year',\n        y='win_pct',\n        color='player_name',\n        markers=True,\n        hover_data=['matches'],\n        labels={\n            'year': 'Year',\n            'win_pct': 'Win % vs Top 10',\n            'player_name': 'Player',\n            'matches': 'Matches'\n        },\n        title=title\n    )\n    \n    fig.update_layout(\n        height=500,\n        legend=dict(\n            orientation='v',\n            x=1.02,\n            y=1,\n            xanchor='left',\n            yanchor='top',\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='#ccc',\n            borderwidth=1,\n            font=dict(size=10)\n        ),\n        margin=dict(r=150),\n        yaxis=dict(range=[0, 100])\n    )\n    \n    return fig\n\nfig_temporal_atp = create_temporal_trends(atp_records, 'ATP: Win Rate vs Top 10 Over Time')\nif fig_temporal_atp:\n    fig_temporal_atp.show()\n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_temporal_wta = create_temporal_trends(wta_records, 'WTA: Win Rate vs Top 10 Over Time')\nif fig_temporal_wta:\n    fig_temporal_wta.show()"
  },
  {
    "objectID": "posts/opponent-quality/opponent-quality.html#view-8-head-to-head-deep-dive",
    "href": "posts/opponent-quality/opponent-quality.html#view-8-head-to-head-deep-dive",
    "title": "Opponent Quality Analysis",
    "section": "",
    "text": "Detailed records against specific top opponents, not just tiers. Filter to show rivalries with 3+ matches and see surface breakdown within each H2H.\n\n\nShow code\ndef create_h2h_matrix(matches_df, player_ids, player_names, title, min_matches=3):\n    \"\"\"Create head-to-head matrix between top 25 players\"\"\"\n    # Build H2H records\n    h2h_records = {}\n    \n    for _, row in matches_df.iterrows():\n        winner_id = row['winner_id']\n        loser_id = row['loser_id']\n        \n        # Only count matches between top 25 players\n        if winner_id in player_ids and loser_id in player_ids:\n            winner_name = player_names.get(winner_id, row['winner_name'])\n            loser_name = player_names.get(loser_id, row['loser_name'])\n            \n            key = tuple(sorted([winner_name, loser_name]))\n            if key not in h2h_records:\n                h2h_records[key] = {'player1': key[0], 'player2': key[1],\n                                    'p1_wins': 0, 'p2_wins': 0,\n                                    'hard_p1': 0, 'hard_p2': 0,\n                                    'clay_p1': 0, 'clay_p2': 0,\n                                    'grass_p1': 0, 'grass_p2': 0}\n            \n            surface = row['surface'].lower() if pd.notna(row['surface']) else 'other'\n            \n            if winner_name == key[0]:\n                h2h_records[key]['p1_wins'] += 1\n                if surface == 'hard':\n                    h2h_records[key]['hard_p1'] += 1\n                elif surface == 'clay':\n                    h2h_records[key]['clay_p1'] += 1\n                elif surface == 'grass':\n                    h2h_records[key]['grass_p1'] += 1\n            else:\n                h2h_records[key]['p2_wins'] += 1\n                if surface == 'hard':\n                    h2h_records[key]['hard_p2'] += 1\n                elif surface == 'clay':\n                    h2h_records[key]['clay_p2'] += 1\n                elif surface == 'grass':\n                    h2h_records[key]['grass_p2'] += 1\n    \n    h2h_df = pd.DataFrame(h2h_records.values())\n    h2h_df['total_matches'] = h2h_df['p1_wins'] + h2h_df['p2_wins']\n    h2h_df = h2h_df[h2h_df['total_matches'] &gt;= min_matches]\n    h2h_df = h2h_df.sort_values('total_matches', ascending=False)\n    \n    if len(h2h_df) == 0:\n        return None\n    \n    # Create display strings\n    h2h_df['h2h'] = h2h_df.apply(lambda x: f\"{x['p1_wins']}-{x['p2_wins']}\", axis=1)\n    h2h_df['hard'] = h2h_df.apply(lambda x: f\"{x['hard_p1']}-{x['hard_p2']}\", axis=1)\n    h2h_df['clay'] = h2h_df.apply(lambda x: f\"{x['clay_p1']}-{x['clay_p2']}\", axis=1)\n    h2h_df['grass'] = h2h_df.apply(lambda x: f\"{x['grass_p1']}-{x['grass_p2']}\", axis=1)\n    h2h_df['matchup'] = h2h_df['player1'] + ' vs ' + h2h_df['player2']\n    \n    # Create table\n    fig = go.Figure(data=[go.Table(\n        header=dict(\n            values=['Matchup', 'H2H', 'Hard', 'Clay', 'Grass', 'Total'],\n            fill_color='#1f77b4',\n            font=dict(color='white', size=12),\n            align='left'\n        ),\n        cells=dict(\n            values=[\n                h2h_df['matchup'],\n                h2h_df['h2h'],\n                h2h_df['hard'],\n                h2h_df['clay'],\n                h2h_df['grass'],\n                h2h_df['total_matches']\n            ],\n            fill_color='white',\n            align='left',\n            height=30\n        )\n    )])\n    \n    fig.update_layout(\n        title=f\"{title} (Minimum {min_matches} matches)\",\n        height=max(400, len(h2h_df) * 35 + 100)\n    )\n    \n    return fig\n\nfig_h2h_atp = create_h2h_matrix(atp_matches, atp_player_ids, atp_player_names, \n                                'ATP: Head-to-Head Records Among Top 25')\nif fig_h2h_atp:\n    fig_h2h_atp.show()\n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_h2h_wta = create_h2h_matrix(wta_matches, wta_player_ids, wta_player_names,\n                                'WTA: Head-to-Head Records Among Top 25')\nif fig_h2h_wta:\n    fig_h2h_wta.show()"
  },
  {
    "objectID": "posts/opponent-quality/opponent-quality.html#summary-statistics",
    "href": "posts/opponent-quality/opponent-quality.html#summary-statistics",
    "title": "Opponent Quality Analysis",
    "section": "",
    "text": "Key metrics for each player summarizing their opponent quality performance.\n\n\nShow code\ndef create_summary_table(records_df, title):\n    \"\"\"Create summary statistics table\"\"\"\n    df = records_df.copy()\n    \n    # Overall stats\n    overall = df.groupby('player_name').agg(\n        total_matches=('won', 'count'),\n        total_wins=('won', 'sum'),\n        avg_opp_rank=('opponent_rank', 'mean')\n    ).reset_index()\n    overall['overall_win_pct'] = (overall['total_wins'] / overall['total_matches'] * 100).round(1)\n    overall['avg_opp_rank'] = overall['avg_opp_rank'].round(0)\n    \n    # Elite performance\n    elite = df[df['opponent_tier'] == 'Elite (1-10)'].groupby('player_name').agg(\n        elite_matches=('won', 'count'),\n        elite_wins=('won', 'sum')\n    ).reset_index()\n    elite['elite_win_pct'] = (elite['elite_wins'] / elite['elite_matches'] * 100).round(1)\n    \n    # Merge\n    summary = overall.merge(elite, on='player_name', how='left')\n    summary['elite_win_pct'] = summary['elite_win_pct'].fillna(0)\n    summary['elite_matches'] = summary['elite_matches'].fillna(0).astype(int)\n    \n    # Calculate drop-off (lower tier win% - elite win%)\n    lower = df[df['opponent_tier'] == 'Lower (100+)'].groupby('player_name').agg(\n        lower_wins=('won', 'sum'),\n        lower_matches=('won', 'count')\n    ).reset_index()\n    lower['lower_win_pct'] = lower['lower_wins'] / lower['lower_matches'] * 100\n    \n    summary = summary.merge(lower[['player_name', 'lower_win_pct']], on='player_name', how='left')\n    summary['dropoff'] = (summary['lower_win_pct'] - summary['elite_win_pct']).round(1)\n    \n    summary = summary.sort_values('elite_win_pct', ascending=False)\n    \n    # Create table\n    fig = go.Figure(data=[go.Table(\n        header=dict(\n            values=['Player', 'Matches', 'Win %', 'Avg Opp Rank', 'vs Elite', 'Elite Win %', 'Drop-off'],\n            fill_color='#1f77b4',\n            font=dict(color='white', size=11),\n            align='left'\n        ),\n        cells=dict(\n            values=[\n                summary['player_name'],\n                summary['total_matches'],\n                summary['overall_win_pct'].astype(str) + '%',\n                summary['avg_opp_rank'].astype(int),\n                summary['elite_matches'].astype(str) + ' matches',\n                summary['elite_win_pct'].astype(str) + '%',\n                summary['dropoff'].apply(lambda x: f\"+{x:.0f}%\" if pd.notna(x) else 'N/A')\n            ],\n            fill_color=[['white', '#f0f0f0'] * (len(summary) // 2 + 1)][:len(summary)],\n            align='left',\n            height=28\n        )\n    )])\n    \n    fig.update_layout(\n        title=title,\n        height=max(400, len(summary) * 32 + 100)\n    )\n    \n    return fig\n\nfig_summary_atp = create_summary_table(atp_records, 'ATP: Player Summary Statistics')\nfig_summary_atp.show()\n\n\n                            \n                                            \n\n\n\n\nShow code\nfig_summary_wta = create_summary_table(wta_records, 'WTA: Player Summary Statistics')\nfig_summary_wta.show()"
  },
  {
    "objectID": "posts/opponent-quality/opponent-quality.html#key-insights",
    "href": "posts/opponent-quality/opponent-quality.html#key-insights",
    "title": "Opponent Quality Analysis",
    "section": "",
    "text": "This analysis reveals several patterns in how players perform against different quality opponents:\n\nElite Beaters: Players with relatively flat drop-off lines maintain strong performance regardless of opponent quality\nStat Padders: Large drop-offs between lower-tier and elite performance may indicate inflated records against weaker opponents\nSurface Specialists: Some players show dramatically different performance by surface when facing top opponents\nBig Stage Performers: Tournament-level breakdown reveals who rises to the occasion at Grand Slams vs smaller events\nTrajectory: Temporal trends show which players are improving or declining against elite competition"
  },
  {
    "objectID": "posts/nb_tutorial/nb_tutorial.html",
    "href": "posts/nb_tutorial/nb_tutorial.html",
    "title": "Authoring delightful documents with Notebooks!",
    "section": "",
    "text": "Code\nTo use a jupyter notebook like this, include the following as raw a cell at the top of your notebook:&lt;br&gt;\ntitle: \"Authoring delightful documents with Notebooks!\"&lt;br&gt;\nauthor: \"Ali Zaidi\"&lt;br&gt;\ndate: \"2022-10-21\"&lt;br&gt;\ncategories: []&lt;br&gt;\ntoc: true&lt;br&gt;\ntoc-depth: 3&lt;br&gt;\ntoc-title: Contents&lt;br&gt;\nimage: \"notebook.png\"&lt;br&gt;\nnumber-sections: true&lt;br&gt;\nformat:&lt;br&gt;\n    html:&lt;br&gt;\n        code-fold: true&lt;br&gt;\n        code-tools: true&lt;br&gt;\nkeep-ipynb: true &lt;br&gt;\njupyter: python3&lt;br&gt;"
  },
  {
    "objectID": "posts/nb_tutorial/nb_tutorial.html#seeing-our-first-plot",
    "href": "posts/nb_tutorial/nb_tutorial.html#seeing-our-first-plot",
    "title": "Authoring delightful documents with Notebooks!",
    "section": "1.1 Seeing our first plot",
    "text": "1.1 Seeing our first plot\n\n1.1.1 Random level in\nJust to show toc-depth field (table of content)\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nx = np.arange(10)\ny = np.random.randint(0, 10, 10)\nplt.plot(x,y)\nplt.title('A random plot!')\nplt.xlabel('our x axis :-p')\nplt.ylabel('our y values');\n\n\n\n\n\na simple plot!\n\n\n\n\n\n\nCode\nnp.array([x,y]).T.shape\n\n\n(10, 2)"
  },
  {
    "objectID": "posts/nb_tutorial/nb_tutorial.html#dataframes-as-well",
    "href": "posts/nb_tutorial/nb_tutorial.html#dataframes-as-well",
    "title": "Authoring delightful documents with Notebooks!",
    "section": "1.2 Dataframes as well!",
    "text": "1.2 Dataframes as well!\n\n\n\n\n\n\n\n\n\ny1\ny2\ny3\n\n\n\n\n0\n5.0\n8.0\n2.5\n\n\n1\n6.0\n9.0\n3.0\n\n\n2\n8.0\n11.0\n4.0\n\n\n3\n1.0\n4.0\n0.5\n\n\n4\n6.0\n9.0\n3.0\n\n\n5\n4.0\n7.0\n2.0\n\n\n6\n4.0\n7.0\n2.0\n\n\n7\n3.0\n6.0\n1.5\n\n\n8\n3.0\n6.0\n1.5\n\n\n9\n3.0\n6.0\n1.5"
  },
  {
    "objectID": "posts/koala-series/koala.html",
    "href": "posts/koala-series/koala.html",
    "title": "A series of Koalas",
    "section": "",
    "text": "By Stable Diffusion\n\nSunrise\n\n\n\nJust hanging out\n\n\n\n&lt;3"
  },
  {
    "objectID": "posts/tennis-ojs/tennis-ojs.html#interactive-dashboard",
    "href": "posts/tennis-ojs/tennis-ojs.html#interactive-dashboard",
    "title": "Tennis Serve Analysis (Interactive)",
    "section": "Interactive Dashboard",
    "text": "Interactive Dashboard\nUse the filters below to explore serve statistics across tours and time periods.\n\n\nFilters\n\nviewof tour = Inputs.radio([\"ATP\", \"WTA\"], {value: \"ATP\", label: \"Tour\"})\n\nviewof period = Inputs.select(\n  [\"all_time\", \"last_5_years\", \"last_1_year\"],\n  {\n    value: \"all_time\",\n    label: \"Time Period\",\n    format: x =&gt; ({\n      \"all_time\": \"All Time\",\n      \"last_5_years\": \"Last 5 Years\",\n      \"last_1_year\": \"Last 1 Year\"\n    })[x]\n  }\n)\n\n// Get available players for selected tour/period\navailablePlayers = {\n  const tourKey = tour.toLowerCase();\n  const data = tennis_data[tourKey][period];\n  return data.players.map(p =&gt; p.player);\n}\n\nviewof playerFilter = Inputs.select(\n  [\"Top 5\", \"Top 10\", \"All Players\"],\n  {value: \"Top 5\", label: \"Player Filter\"}\n)\n\n// Calculate default selected players based on filter\ndefaultPlayers = {\n  const n = playerFilter === \"Top 5\" ? 5 : playerFilter === \"Top 10\" ? 10 : availablePlayers.length;\n  return availablePlayers.slice(0, n);\n}\n\nviewof selectedPlayers = Inputs.checkbox(\n  availablePlayers,\n  {value: defaultPlayers, label: \"Select Players\"}\n)\n\nviewof highlightPlayer = Inputs.select(\n  [\"None\", ...selectedPlayers],\n  {value: \"None\", label: \"Highlight Player\"}\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncurrentData = {\n  const tourKey = tour.toLowerCase();\n  return tennis_data[tourKey][period];\n}\n\n// Filter players based on selection\nfilteredPlayers = currentData.players.filter(p =&gt; selectedPlayers.includes(p.player))\n\n// Calculate averages for the filtered group\ngroupAverages = {\n  const players = filteredPlayers;\n  if (players.length === 0) return {};\n\n  return {\n    ace_rate: d3.mean(players, d =&gt; d.ace_rate),\n    df_rate: d3.mean(players, d =&gt; d.df_rate),\n    first_serve_pct: d3.mean(players, d =&gt; d.first_serve_pct),\n    first_serve_won: d3.mean(players, d =&gt; d.first_serve_won),\n    bp_save_pct: d3.mean(players.filter(d =&gt; d.bp_save_pct), d =&gt; d.bp_save_pct),\n    bp_convert_pct: d3.mean(players.filter(d =&gt; d.bp_convert_pct), d =&gt; d.bp_convert_pct),\n  };\n}\n\n// Surface data filtered by selected players\nfilteredSurface = currentData.surface.filter(s =&gt; selectedPlayers.includes(s.player))\n\n// Colors\ntourColor = tour === \"ATP\" ? \"#1f77b4\" : \"#e377c2\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTour Averages\n\nhtml`&lt;div style=\"display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-bottom: 2rem;\"&gt;\n  &lt;div style=\"background: linear-gradient(135deg, ${tour === 'ATP' ? '#667eea' : '#e377c2'} 0%, ${tour === 'ATP' ? '#764ba2' : '#c44569'} 100%); padding: 1rem; border-radius: 10px; color: white; text-align: center;\"&gt;\n    &lt;div style=\"font-size: 2rem; font-weight: bold;\"&gt;${currentData.tour_avg.aces_per_match}&lt;/div&gt;\n    &lt;div style=\"font-size: 0.9rem; opacity: 0.9;\"&gt;Aces/Match&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div style=\"background: linear-gradient(135deg, ${tour === 'ATP' ? '#667eea' : '#e377c2'} 0%, ${tour === 'ATP' ? '#764ba2' : '#c44569'} 100%); padding: 1rem; border-radius: 10px; color: white; text-align: center;\"&gt;\n    &lt;div style=\"font-size: 2rem; font-weight: bold;\"&gt;${currentData.tour_avg.first_serve_in_pct}%&lt;/div&gt;\n    &lt;div style=\"font-size: 0.9rem; opacity: 0.9;\"&gt;1st Serve In&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div style=\"background: linear-gradient(135deg, ${tour === 'ATP' ? '#667eea' : '#e377c2'} 0%, ${tour === 'ATP' ? '#764ba2' : '#c44569'} 100%); padding: 1rem; border-radius: 10px; color: white; text-align: center;\"&gt;\n    &lt;div style=\"font-size: 2rem; font-weight: bold;\"&gt;${currentData.tour_avg.first_serve_won_pct}%&lt;/div&gt;\n    &lt;div style=\"font-size: 0.9rem; opacity: 0.9;\"&gt;1st Serve Won&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div style=\"background: linear-gradient(135deg, ${tour === 'ATP' ? '#667eea' : '#e377c2'} 0%, ${tour === 'ATP' ? '#764ba2' : '#c44569'} 100%); padding: 1rem; border-radius: 10px; color: white; text-align: center;\"&gt;\n    &lt;div style=\"font-size: 2rem; font-weight: bold;\"&gt;${currentData.tour_avg.second_serve_won_pct}%&lt;/div&gt;\n    &lt;div style=\"font-size: 0.9rem; opacity: 0.9;\"&gt;2nd Serve Won&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;`\n\n\n\n\n\n\n\n\nAce Production: Risk vs Reward\nBig servers hit more aces but often double fault more too.\n\nPlot.plot({\n  width: 800,\n  height: 450,\n  marginRight: 60,\n  grid: true,\n  x: {label: \"Ace Rate %\", domain: [0, d3.max(filteredPlayers, d =&gt; d.ace_rate) * 1.1]},\n  y: {label: \"Double Fault Rate %\", domain: [0, d3.max(filteredPlayers, d =&gt; d.df_rate) * 1.1]},\n  marks: [\n    // Average reference lines\n    Plot.ruleX([groupAverages.ace_rate], {stroke: \"gray\", strokeDasharray: \"4,4\", strokeOpacity: 0.5}),\n    Plot.ruleY([groupAverages.df_rate], {stroke: \"gray\", strokeDasharray: \"4,4\", strokeOpacity: 0.5}),\n    // Points\n    Plot.dot(filteredPlayers, {\n      x: \"ace_rate\",\n      y: \"df_rate\",\n      r: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? 12 : 8,\n      fill: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"gold\" : tourColor,\n      stroke: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"darkred\" : \"white\",\n      strokeWidth: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? 3 : 1,\n      title: d =&gt; `${d.player} (#${d.rank})\\nAce Rate: ${d.ace_rate}%\\nDF Rate: ${d.df_rate}%\\nMatches: ${d.matches}`,\n    }),\n    // Labels\n    Plot.text(filteredPlayers, {\n      x: \"ace_rate\",\n      y: \"df_rate\",\n      text: \"player\",\n      dy: -12,\n      fontSize: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? 12 : 10,\n      fontWeight: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"bold\" : \"normal\",\n      fill: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"darkred\" : \"black\",\n    }),\n  ]\n})\n\n\n\n\n\n\n\n\nFirst Serve: Accuracy vs Effectiveness\nGetting the first serve in is important, but winning the point matters more.\n\nPlot.plot({\n  width: 800,\n  height: 450,\n  marginRight: 60,\n  grid: true,\n  x: {label: \"1st Serve In %\", domain: [d3.min(filteredPlayers, d =&gt; d.first_serve_pct) * 0.95, d3.max(filteredPlayers, d =&gt; d.first_serve_pct) * 1.02]},\n  y: {label: \"1st Serve Won %\", domain: [d3.min(filteredPlayers, d =&gt; d.first_serve_won) * 0.95, d3.max(filteredPlayers, d =&gt; d.first_serve_won) * 1.02]},\n  marks: [\n    // Average reference lines\n    Plot.ruleX([groupAverages.first_serve_pct], {stroke: \"gray\", strokeDasharray: \"4,4\", strokeOpacity: 0.5}),\n    Plot.ruleY([groupAverages.first_serve_won], {stroke: \"gray\", strokeDasharray: \"4,4\", strokeOpacity: 0.5}),\n    // Points\n    Plot.dot(filteredPlayers, {\n      x: \"first_serve_pct\",\n      y: \"first_serve_won\",\n      r: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? 12 : 8,\n      fill: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"gold\" : tourColor,\n      stroke: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"darkred\" : \"white\",\n      strokeWidth: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? 3 : 1,\n      title: d =&gt; `${d.player} (#${d.rank})\\n1st Serve In: ${d.first_serve_pct}%\\n1st Serve Won: ${d.first_serve_won}%`,\n    }),\n    // Labels\n    Plot.text(filteredPlayers, {\n      x: \"first_serve_pct\",\n      y: \"first_serve_won\",\n      text: \"player\",\n      dy: -12,\n      fontSize: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? 12 : 10,\n      fontWeight: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"bold\" : \"normal\",\n      fill: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"darkred\" : \"black\",\n    }),\n  ]\n})\n\n\n\n\n\n\n\n\nBreak Point Performance\nClutch players both save break points on serve and convert them on return.\n\nbpPlayers = filteredPlayers.filter(p =&gt; p.bp_save_pct && p.bp_convert_pct)\n\nPlot.plot({\n  width: 800,\n  height: 450,\n  marginRight: 60,\n  grid: true,\n  x: {label: \"BP Save %\", domain: [d3.min(bpPlayers, d =&gt; d.bp_save_pct) * 0.95, d3.max(bpPlayers, d =&gt; d.bp_save_pct) * 1.02]},\n  y: {label: \"BP Convert %\", domain: [d3.min(bpPlayers, d =&gt; d.bp_convert_pct) * 0.95, d3.max(bpPlayers, d =&gt; d.bp_convert_pct) * 1.02]},\n  marks: [\n    // Average reference lines\n    Plot.ruleX([groupAverages.bp_save_pct], {stroke: \"gray\", strokeDasharray: \"4,4\", strokeOpacity: 0.5}),\n    Plot.ruleY([groupAverages.bp_convert_pct], {stroke: \"gray\", strokeDasharray: \"4,4\", strokeOpacity: 0.5}),\n    // Points\n    Plot.dot(bpPlayers, {\n      x: \"bp_save_pct\",\n      y: \"bp_convert_pct\",\n      r: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? 12 : 8,\n      fill: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"gold\" : tourColor,\n      stroke: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"darkred\" : \"white\",\n      strokeWidth: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? 3 : 1,\n      title: d =&gt; `${d.player} (#${d.rank})\\nBP Save: ${d.bp_save_pct}%\\nBP Convert: ${d.bp_convert_pct}%`,\n    }),\n    // Labels\n    Plot.text(bpPlayers, {\n      x: \"bp_save_pct\",\n      y: \"bp_convert_pct\",\n      text: \"player\",\n      dy: -12,\n      fontSize: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? 12 : 10,\n      fontWeight: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"bold\" : \"normal\",\n      fill: d =&gt; highlightPlayer !== \"None\" && d.player === highlightPlayer ? \"darkred\" : \"black\",\n    }),\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSurface Analysis\nGrass favors servers (fast, low bounce). Clay neutralizes the serve (slow, high bounce).\n\nsurfaceColors = ({Hard: \"#1f77b4\", Clay: \"#d62728\", Grass: \"#2ca02c\"})\n\nPlot.plot({\n  width: 700,\n  height: 350,\n  marginBottom: 40,\n  x: {label: \"Surface\", padding: 0.3},\n  y: {label: \"Aces per Match\", domain: [0, d3.max(currentData.surface_avg, d =&gt; d.aces_per_match) * 1.2]},\n  marks: [\n    Plot.barY(currentData.surface_avg, {\n      x: \"surface\",\n      y: \"aces_per_match\",\n      fill: d =&gt; surfaceColors[d.surface],\n      title: d =&gt; `${d.surface}\\nAces/Match: ${d.aces_per_match}\\n1st Won: ${d.first_won_pct}%`\n    }),\n    Plot.text(currentData.surface_avg, {\n      x: \"surface\",\n      y: \"aces_per_match\",\n      text: d =&gt; d.aces_per_match,\n      dy: -8,\n      fontSize: 14,\n      fontWeight: \"bold\"\n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlayer Surface Profiles\nHow does each playerâ€™s serve performance vary across surfaces?\n\nsurfacePivot = {\n  const players = [...new Set(filteredSurface.map(d =&gt; d.player))];\n  const surfaces = [\"Hard\", \"Clay\", \"Grass\"];\n\n  // Create pivot with player/rank pairs\n  const result = [];\n  for (const player of players) {\n    const playerData = filteredSurface.filter(d =&gt; d.player === player);\n    if (playerData.length &gt; 0) {\n      const row = {\n        player: player,\n        rank: playerData[0].rank\n      };\n      for (const surface of surfaces) {\n        const surfData = playerData.find(d =&gt; d.surface === surface);\n        row[surface] = surfData ? surfData.ace_rate : null;\n      }\n      result.push(row);\n    }\n  }\n\n  // Sort by rank and take top 12\n  return result.sort((a, b) =&gt; a.rank - b.rank).slice(0, 12);\n}\n\n// Flatten for heatmap\nheatmapData = {\n  const data = [];\n  const surfaces = [\"Hard\", \"Clay\", \"Grass\"];\n  for (const row of surfacePivot) {\n    for (const surface of surfaces) {\n      if (row[surface] !== null) {\n        data.push({\n          player: row.player,\n          surface: surface,\n          ace_rate: row[surface]\n        });\n      }\n    }\n  }\n  return data;\n}\n\nPlot.plot({\n  width: 600,\n  height: 400,\n  marginLeft: 80,\n  marginBottom: 40,\n  color: {\n    scheme: tour === \"ATP\" ? \"blues\" : \"RdPu\",\n    legend: true,\n    label: \"Ace Rate %\"\n  },\n  x: {label: \"Surface\", padding: 0.1},\n  y: {label: null, padding: 0.1},\n  marks: [\n    Plot.cell(heatmapData, {\n      x: \"surface\",\n      y: \"player\",\n      fill: \"ace_rate\",\n      title: d =&gt; `${d.player}\\n${d.surface}: ${d.ace_rate}%`\n    }),\n    Plot.text(heatmapData, {\n      x: \"surface\",\n      y: \"player\",\n      text: d =&gt; d.ace_rate ? `${d.ace_rate}%` : \"\",\n      fill: d =&gt; d.ace_rate &gt; 8 ? \"white\" : \"black\",\n      fontSize: 11\n    })\n  ]\n})"
  },
  {
    "objectID": "posts/tennis-ojs/tennis-ojs.html#highlighted-player-comparison",
    "href": "posts/tennis-ojs/tennis-ojs.html#highlighted-player-comparison",
    "title": "Tennis Serve Analysis (Interactive)",
    "section": "Highlighted Player Comparison",
    "text": "Highlighted Player Comparison\n\nhighlightedStats = {\n  if (highlightPlayer === \"None\") return null;\n  return filteredPlayers.find(p =&gt; p.player === highlightPlayer);\n}\n\nhtml`${highlightPlayer !== \"None\" && highlightedStats ? html`\n&lt;div style=\"background: #f8f9fa; padding: 1.5rem; border-radius: 10px; margin: 1rem 0;\"&gt;\n  &lt;h4 style=\"margin-top: 0;\"&gt;${highlightedStats.full_name} (#${highlightedStats.rank}) vs Selected Players&lt;/h4&gt;\n  &lt;div style=\"display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;\"&gt;\n    &lt;div style=\"background: white; padding: 1rem; border-radius: 8px; border-left: 4px solid ${highlightedStats.ace_rate &gt; groupAverages.ace_rate ? 'green' : 'red'};\"&gt;\n      &lt;div style=\"font-size: 0.75rem; color: #666;\"&gt;Ace Rate&lt;/div&gt;\n      &lt;div style=\"font-size: 1.4rem; font-weight: bold;\"&gt;${highlightedStats.ace_rate}%&lt;/div&gt;\n      &lt;div style=\"font-size: 0.8rem; color: ${highlightedStats.ace_rate &gt; groupAverages.ace_rate ? 'green' : 'red'};\"&gt;\n        ${(highlightedStats.ace_rate - groupAverages.ace_rate).toFixed(1)}% vs avg (${groupAverages.ace_rate.toFixed(1)}%)\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div style=\"background: white; padding: 1rem; border-radius: 8px; border-left: 4px solid ${highlightedStats.first_serve_won &gt; groupAverages.first_serve_won ? 'green' : 'red'};\"&gt;\n      &lt;div style=\"font-size: 0.75rem; color: #666;\"&gt;1st Serve Won&lt;/div&gt;\n      &lt;div style=\"font-size: 1.4rem; font-weight: bold;\"&gt;${highlightedStats.first_serve_won}%&lt;/div&gt;\n      &lt;div style=\"font-size: 0.8rem; color: ${highlightedStats.first_serve_won &gt; groupAverages.first_serve_won ? 'green' : 'red'};\"&gt;\n        ${(highlightedStats.first_serve_won - groupAverages.first_serve_won).toFixed(1)}% vs avg (${groupAverages.first_serve_won.toFixed(1)}%)\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div style=\"background: white; padding: 1rem; border-radius: 8px; border-left: 4px solid ${highlightedStats.bp_save_pct &gt; groupAverages.bp_save_pct ? 'green' : 'red'};\"&gt;\n      &lt;div style=\"font-size: 0.75rem; color: #666;\"&gt;BP Save&lt;/div&gt;\n      &lt;div style=\"font-size: 1.4rem; font-weight: bold;\"&gt;${highlightedStats.bp_save_pct}%&lt;/div&gt;\n      &lt;div style=\"font-size: 0.8rem; color: ${highlightedStats.bp_save_pct &gt; groupAverages.bp_save_pct ? 'green' : 'red'};\"&gt;\n        ${(highlightedStats.bp_save_pct - groupAverages.bp_save_pct).toFixed(1)}% vs avg (${groupAverages.bp_save_pct.toFixed(1)}%)\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n` : html`&lt;p style=\"color: #666; font-style: italic;\"&gt;Select a player to highlight from the sidebar to see detailed comparison.&lt;/p&gt;`}`"
  },
  {
    "objectID": "posts/tennis-ojs/tennis-ojs.html#key-takeaways",
    "href": "posts/tennis-ojs/tennis-ojs.html#key-takeaways",
    "title": "Tennis Serve Analysis (Interactive)",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nWinners outserve losers across all metrics, with the biggest gaps in 1st serve win % and break point save %\nATP players hit 2x more aces than WTA players on average\nBreak point save % is the most predictive stat - it combines serving ability with clutch performance\nSurface matters: Grass produces the most aces; clay neutralizes serve advantages\n\n\nData source: Tennis Abstract | Dashboard built with Quarto and Observable JS"
  },
  {
    "objectID": "posts/scraping-tutorial/scraping-tutorial.html",
    "href": "posts/scraping-tutorial/scraping-tutorial.html",
    "title": "Web Scraping Tennis Abstract with Playwright",
    "section": "",
    "text": "Introduction\nTennis Abstract is one of the best resources for tennis statistics on the web. Created by Jeff Sackmann, it provides detailed match histories, serve statistics, and performance data for professional tennis players.\nThe challenge: Tennis Abstract uses JavaScript to render its data tables. If you try scraping with requests + BeautifulSoup, youâ€™ll get an empty page because the content loads dynamically after the initial HTML.\nThe solution: Playwright - a modern browser automation library that can: - Launch a real browser (headless or visible) - Wait for JavaScript to execute - Extract data from the fully-rendered page\nIn this tutorial, weâ€™ll build a scraper to fetch player match histories and serve statistics, then visualize the data.\n\n\n\n\n\n\nSync vs Async API\n\n\n\nPlaywright offers both synchronous and asynchronous APIs. In Jupyter notebooks, we must use the async API because notebooks run inside an asyncio event loop. For standalone scripts, the sync API (sync_playwright) is simpler.\n\n\n\n\nSetup\nFirst, install the required packages:\npip install playwright pandas plotly\nplaywright install chromium\nThe second command downloads a Chromium browser for Playwright to control.\n\nfrom playwright.async_api import async_playwright\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom datetime import datetime\nimport asyncio\nimport re\n\n\n\nUnderstanding the Target Page\nEach player on Tennis Abstract has a page like: - ATP: https://www.tennisabstract.com/cgi-bin/player.cgi?p=JannikSinner - WTA: https://www.tennisabstract.com/cgi-bin/wplayer.cgi?p=IgaSwiatek\nThe recent matches table has the ID #recent-results and contains these columns:\n\n\n\nIndex\nColumn\nDescription\n\n\n\n\n0\nDate\nMatch date (e.g., â€œ19-Jan-2026â€)\n\n\n1\nTournament\nTournament name\n\n\n2\nSurface\nHard, Clay, or Grass\n\n\n3\nRd\nRound (F, SF, QF, R16, etc.)\n\n\n4\nRk\nPlayerâ€™s ranking at match time\n\n\n5\nvRk\nOpponentâ€™s ranking\n\n\n6\nResult\nWho won (e.g., â€œSinner d.Â Djokovicâ€)\n\n\n7\nScore\nMatch score\n\n\n8\nDR\nDelta ranking\n\n\n9\nA%\nAce percentage\n\n\n10\nDF%\nDouble fault percentage\n\n\n11\n1stIn\nFirst serve in percentage\n\n\n12\n1st%\nFirst serve points won\n\n\n13\n2nd%\nSecond serve points won\n\n\n14\nBPSvd\nBreak points saved\n\n\n15\nTime\nMatch duration\n\n\n\n\n\nBuilding the Scraper\nLetâ€™s build a scraper that captures both match results and serve statistics:\n\ndef parse_result(result_text: str, player_name: str) -&gt; dict:\n    \"\"\"Parse the result cell to extract win/loss and opponent info.\"\"\"\n    if \" d. \" not in result_text:\n        return {\"won\": None, \"opponent\": None}\n    \n    winner_part, loser_part = result_text.split(\" d. \")\n    \n    def extract_name(text):\n        text = re.sub(r'\\(\\d+\\)', '', text)  # Remove seed\n        text = re.sub(r'\\[.*?\\]', '', text)  # Remove country\n        text = re.sub(r'\\(WC\\)|\\(Q\\)|\\(LL\\)', '', text)  # Remove entry type\n        return text.strip()\n    \n    winner_name = extract_name(winner_part)\n    loser_name = extract_name(loser_part)\n    player_won = player_name.lower() in winner_name.lower()\n    \n    return {\n        \"won\": player_won,\n        \"opponent\": loser_name if player_won else winner_name\n    }\n\n\ndef parse_percentage(text: str) -&gt; float:\n    \"\"\"Parse percentage string like '65%' or '65' to float.\"\"\"\n    try:\n        return float(text.replace('%', '').strip())\n    except (ValueError, AttributeError):\n        return None\n\n\ndef parse_date(date_str: str) -&gt; datetime:\n    \"\"\"Parse date string like '19-Jan-2026' to datetime.\"\"\"\n    try:\n        return datetime.strptime(date_str.strip(), \"%d-%b-%Y\")\n    except ValueError:\n        return None\n\n\nasync def scrape_player_with_stats(player_url_name: str, player_last_name: str, tour: str = \"atp\") -&gt; pd.DataFrame:\n    \"\"\"\n    Scrape recent matches with serve statistics for a player.\n    \n    Args:\n        player_url_name: Player name in URL format (e.g., \"JannikSinner\")\n        player_last_name: Player's last name for result parsing\n        tour: \"atp\" or \"wta\"\n    \n    Returns:\n        DataFrame with match data and serve stats\n    \"\"\"\n    prefix = \"w\" if tour == \"wta\" else \"\"\n    url = f\"https://www.tennisabstract.com/cgi-bin/{prefix}player.cgi?p={player_url_name}\"\n    \n    async with async_playwright() as p:\n        browser = await p.chromium.launch(headless=True)\n        page = await browser.new_page()\n        await page.goto(url, wait_until=\"domcontentloaded\")\n        await page.wait_for_timeout(3000)\n        \n        table = await page.query_selector(\"#recent-results\")\n        if not table:\n            print(f\"Could not find table for {player_last_name}\")\n            await browser.close()\n            return pd.DataFrame()\n        \n        rows = await table.query_selector_all(\"tr\")\n        rows = rows[1:]  # Skip header\n        matches = []\n        \n        for row in rows:\n            cells = await row.query_selector_all(\"td\")\n            cell_texts = [await cell.inner_text() for cell in cells]\n            cell_texts = [text.strip() for text in cell_texts]\n            \n            if len(cell_texts) &gt;= 12:  # Need serve stats columns\n                result_info = parse_result(cell_texts[6], player_last_name)\n                \n                matches.append({\n                    \"player\": player_last_name,\n                    \"date\": parse_date(cell_texts[0]),\n                    \"tournament\": cell_texts[1],\n                    \"surface\": cell_texts[2],\n                    \"round\": cell_texts[3],\n                    \"won\": result_info[\"won\"],\n                    \"opponent\": result_info[\"opponent\"],\n                    \"score\": cell_texts[7],\n                    \"ace_pct\": parse_percentage(cell_texts[9]) if len(cell_texts) &gt; 9 else None,\n                    \"df_pct\": parse_percentage(cell_texts[10]) if len(cell_texts) &gt; 10 else None,\n                    \"first_serve_pct\": parse_percentage(cell_texts[11]) if len(cell_texts) &gt; 11 else None,\n                    \"first_serve_won_pct\": parse_percentage(cell_texts[12]) if len(cell_texts) &gt; 12 else None,\n                    \"second_serve_won_pct\": parse_percentage(cell_texts[13]) if len(cell_texts) &gt; 13 else None,\n                })\n        \n        await browser.close()\n    \n    return pd.DataFrame(matches)\n\n\n\nExample: Scraping Jannik Sinnerâ€™s Matches\nLetâ€™s test our scraper by fetching Sinnerâ€™s recent match history with serve stats:\n\nsinner_matches = await scrape_player_with_stats(\"JannikSinner\", \"Sinner\", tour=\"atp\")\n\nprint(f\"Found {len(sinner_matches)} matches for Sinner\")\nsinner_matches[[\"date\", \"tournament\", \"opponent\", \"won\", \"first_serve_pct\", \"ace_pct\"]].head(10)\n\nFound 21 matches for Sinner\n\n\n\n\n\n\n\n\n\ndate\ntournament\nopponent\nwon\nfirst_serve_pct\nace_pct\n\n\n\n\n0\n2026-01-19\nAustralian Open\nNovak Djokovic\nFalse\n75.2\n19.5\n\n\n1\n2026-01-19\nAustralian Open\nBen Shelton\nTrue\n59.3\n5.5\n\n\n2\n2026-01-19\nAustralian Open\nLuciano Darderi\nTrue\n72.1\n22.1\n\n\n3\n2026-01-19\nAustralian Open\nEliot Spizzirri\nTrue\n66.7\n12.9\n\n\n4\n2026-01-19\nAustralian Open\nJames Duckworth\nTrue\n64.9\n23.4\n\n\n5\n2026-01-19\nAustralian Open\nHugo Gaston\nTrue\n64.4\n13.3\n\n\n6\n2025-11-09\nTour Finals\nCarlos Alcaraz\nTrue\n55.1\n10.3\n\n\n7\n2025-11-09\nTour Finals\nAlex De Minaur\nTrue\n74.6\n11.9\n\n\n8\n2025-11-09\nTour Finals\nAlexander Zverev\nTrue\n70.6\n17.6\n\n\n9\n2025-11-09\nTour Finals\nBen Shelton\nTrue\n74.6\n17.5\n\n\n\n\n\n\n\n\n\nComparing Two Players\nNow letâ€™s scrape data for both Sinner and Alcaraz to compare their serve statistics. Weâ€™ll add a small delay between requests to be respectful to the server.\n\n# Scrape Alcaraz (with rate limiting)\nawait asyncio.sleep(2)  # Be nice to the server\nalcaraz_matches = await scrape_player_with_stats(\"CarlosAlcaraz\", \"Alcaraz\", tour=\"atp\")\n\nprint(f\"Found {len(alcaraz_matches)} matches for Alcaraz\")\n\n# Combine the data\nall_matches = pd.concat([sinner_matches, alcaraz_matches], ignore_index=True)\nall_matches = all_matches.dropna(subset=[\"date\", \"first_serve_pct\"])\nall_matches = all_matches.sort_values(\"date\")\n\nprint(f\"\\nTotal matches with serve data: {len(all_matches)}\")\nall_matches.groupby(\"player\").size()\n\nFound 20 matches for Alcaraz\n\nTotal matches with serve data: 41\n\n\nplayer\nAlcaraz    20\nSinner     21\ndtype: int64\n\n\n\n\nVisualizing First Serve Percentage\nLetâ€™s create an interactive plot comparing Sinner and Alcarazâ€™s first serve percentage over time:\n\n# Create the comparison plot\nfig = px.scatter(\n    all_matches,\n    x=\"date\",\n    y=\"first_serve_pct\",\n    color=\"player\",\n    hover_data=[\"tournament\", \"opponent\", \"won\", \"surface\"],\n    title=\"First Serve % Over Time: Sinner vs Alcaraz\",\n    labels={\n        \"date\": \"Date\",\n        \"first_serve_pct\": \"First Serve %\",\n        \"player\": \"Player\"\n    },\n    color_discrete_map={\"Sinner\": \"#e94560\", \"Alcaraz\": \"#4facfe\"}\n)\n\n# Add trend lines\nfor player, color in [(\"Sinner\", \"#e94560\"), (\"Alcaraz\", \"#4facfe\")]:\n    player_data = all_matches[all_matches[\"player\"] == player].copy()\n    if len(player_data) &gt; 1:\n        # Rolling average for trend\n        player_data = player_data.sort_values(\"date\")\n        player_data[\"rolling_avg\"] = player_data[\"first_serve_pct\"].rolling(window=5, min_periods=1).mean()\n        \n        fig.add_trace(go.Scatter(\n            x=player_data[\"date\"],\n            y=player_data[\"rolling_avg\"],\n            mode=\"lines\",\n            name=f\"{player} (5-match avg)\",\n            line=dict(color=color, width=2, dash=\"dash\"),\n            hoverinfo=\"skip\"\n        ))\n\nfig.update_layout(\n    height=500,\n    hovermode=\"closest\",\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"center\", x=0.5)\n)\n\nfig.show()\n\n        \n        \n        \n\n\n                            \n                                            \n\n\n\n\nSummary Statistics\nLetâ€™s compare their average serve statistics:\n\n# Calculate summary statistics\nsummary = all_matches.groupby(\"player\").agg({\n    \"first_serve_pct\": [\"mean\", \"std\", \"min\", \"max\"],\n    \"ace_pct\": \"mean\",\n    \"df_pct\": \"mean\",\n    \"won\": \"mean\"\n}).round(1)\n\nsummary.columns = [\"1st Serve % (avg)\", \"1st Serve % (std)\", \"1st Serve % (min)\", \"1st Serve % (max)\",\n                   \"Ace % (avg)\", \"DF % (avg)\", \"Win Rate\"]\nsummary[\"Win Rate\"] = (summary[\"Win Rate\"] * 100).round(1)\n\nprint(\"Serve Statistics Comparison\")\nprint(\"=\" * 50)\nsummary\n\nServe Statistics Comparison\n==================================================\n\n\n\n\n\n\n\n\n\n1st Serve % (avg)\n1st Serve % (std)\n1st Serve % (min)\n1st Serve % (max)\nAce % (avg)\nDF % (avg)\nWin Rate\n\n\nplayer\n\n\n\n\n\n\n\n\n\n\n\nAlcaraz\n66.4\n4.6\n57.8\n76.8\n6.5\n2.2\n80.0\n\n\nSinner\n67.8\n5.5\n55.1\n75.2\n13.0\n1.5\n100.0\n\n\n\n\n\n\n\n\n\nFirst Serve % by Surface\nHow does their first serve vary across different surfaces?\n\n# Group by player and surface\nsurface_stats = all_matches.groupby([\"player\", \"surface\"]).agg({\n    \"first_serve_pct\": \"mean\",\n    \"date\": \"count\"\n}).reset_index()\nsurface_stats.columns = [\"player\", \"surface\", \"first_serve_pct\", \"matches\"]\n\n# Only show surfaces with enough matches\nsurface_stats = surface_stats[surface_stats[\"matches\"] &gt;= 3]\n\nfig = px.bar(\n    surface_stats,\n    x=\"surface\",\n    y=\"first_serve_pct\",\n    color=\"player\",\n    barmode=\"group\",\n    title=\"Average First Serve % by Surface\",\n    labels={\"first_serve_pct\": \"First Serve %\", \"surface\": \"Surface\"},\n    color_discrete_map={\"Sinner\": \"#e94560\", \"Alcaraz\": \"#4facfe\"},\n    text=\"first_serve_pct\"\n)\n\nfig.update_traces(texttemplate=\"%{text:.1f}%\", textposition=\"outside\")\nfig.update_layout(height=400, yaxis_range=[50, 75])\nfig.show()\n\n                            \n                                            \n\n\n\n\nRate Limiting & Ethics\nWhen scraping any website, be a good citizen:\n\nRate limit your requests - Add delays between page loads (e.g., 2 seconds)\nRespect robots.txt - Check if scraping is allowed\nDonâ€™t overload servers - Scrape during off-peak hours for large jobs\nCredit the source - Tennis Abstract data is maintained by Jeff Sackmann\n\nimport asyncio\n\nplayers = [\"JannikSinner\", \"CarlosAlcaraz\", \"NovakDjokovic\"]\nfor player in players:\n    data = await scrape_player_with_stats(player, player.split()[-1])\n    await asyncio.sleep(2)  # Wait 2 seconds between requests\n\n\nUsing the Sync API (for Scripts)\nIf youâ€™re writing a standalone Python script (not a notebook), you can use the simpler synchronous API:\nfrom playwright.sync_api import sync_playwright\n\ndef scrape_player_with_stats(player_url_name: str, player_last_name: str, tour: str = \"atp\"):\n    prefix = \"w\" if tour == \"wta\" else \"\"\n    url = f\"https://www.tennisabstract.com/cgi-bin/{prefix}player.cgi?p={player_url_name}\"\n    \n    with sync_playwright() as p:\n        browser = p.chromium.launch(headless=True)\n        page = browser.new_page()\n        page.goto(url, wait_until=\"domcontentloaded\")\n        page.wait_for_timeout(3000)\n        \n        # ... rest of scraping logic (without await)\n        \n        browser.close()\nThe sync API is cleaner for scripts, but wonâ€™t work inside Jupyter notebooks or other async contexts.\n\n\nConclusion\nIn this tutorial, we built a web scraper for Tennis Abstract using Playwright and used it to compare serve statistics between Jannik Sinner and Carlos Alcaraz. Key takeaways:\n\nPlaywright handles JavaScript-rendered content that traditional scraping tools canâ€™t\nUse the async API in notebooks, sync API in scripts\nWait for content to load before extracting data\nParse serve statistics for deeper analysis beyond win/loss records\nVisualize trends with interactive Plotly charts\nBe respectful - rate limit and credit your sources\n\nFor a more comprehensive scraper that handles multiple players and outputs CSV compatible with Jeff Sackmannâ€™s data format, check out the full implementation at data/scrape_tennisabstract.py in this repository.\n\nData source: Tennis Abstract by Jeff Sackmann. Match data is made available under the CC BY-NC-SA 4.0 license."
  }
]